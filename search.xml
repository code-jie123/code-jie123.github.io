<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>opencv绘图</title>
      <link href="/2021/10/16/opencv%E7%BB%98%E5%9B%BE/"/>
      <url>/2021/10/16/opencv%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><strong>介绍 opencv 中常用的一些绘图函数<br>cv.line()，cv.circle()，cv.rectangle()，cv.ellipse()，cv.putText()等。<br>在上述所有功能中，有一些常见的参数，如下所示:</strong></p><span id="more"></span><ul><li><strong>img</strong>: 要绘制形状的图像</li><li><strong>color</strong>: 形状的颜色。对于 BGR，将其作为元组传递，例如：(255,0,0)蓝色。对于灰度，只需传递标量值即可。</li><li><strong>thickness</strong>: 线条粗细。<strong>如果对闭合图形（如圆）传递-1(或 cv.FILLED)</strong> ，它将填充形状。默认= 1</li><li><strong>lineType</strong>: 线的类型。<br><strong>注意</strong>：这里的 lineType 不是指线型是实线还是虚线等，而是指<strong>线的产生算法</strong>。<ul><li><strong>cv.LINE_AA</strong>：给出了抗锯齿的线条，非常适合曲线。(cv.LINE_AA=16)</li><li><strong>cv.LINE_4</strong>: 4 连通线</li><li><strong>cv.LINE_8</strong>: 8 连通线，默认。</li><li><strong>cv.FILLED</strong>: cv.FILLED=-1</li></ul></li><li><strong>shift</strong>: 缩放参数，会将中心点以及线的长度按比例缩小，d=D/$2^{shift}$</li></ul><hr><h2 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h2><p><code>cv.line(img,pt1,pt2,color,thickness,lineType,shift)</code></p><ul><li>pt1: 开始坐标</li><li>pt2: 结束坐标</li></ul><p>要绘制一条线，需要传递线的开始和结束坐标。我们将创建一个黑色图像，并从左上角到右下角在其上绘制一条蓝线。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 创建height=512,width=512的黑色3通道图像</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"><span class="comment"># 绘制一条粗细为5的蓝色对角线</span></span><br><span class="line">cv.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h2><p><code>cv.rectangle(img,pt1,pt2,color,thickness,lineType,shift)</code></p><ul><li>pt1:矩形的左上角坐标</li><li>pt2:矩形的右下角坐标</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.rectangle(img,(<span class="number">384</span>,<span class="number">0</span>),(<span class="number">510</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h2><p><code>cv.circle(img,center,radius,color,thickness,lineType,shift)</code></p><p>要绘制一个圆，需要其中心坐标和半径。我们将在上面绘制的矩形内绘制一个圆。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv.circle(img,(<span class="number">200</span>,<span class="number">200</span>), <span class="number">67</span>, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 这里因为thickness=-1,所以圆会被填充</span></span><br></pre></td></tr></table></figure><hr><h2 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h2><p><code>cv.ellipse(img,center,axes,angle,startAngle,endAngle,thickness,lineType,shift)</code></p><ul><li>center: 椭圆的中心</li><li>axes: 椭圆的轴长(半长短轴)</li><li>angle:椭圆沿水平方向逆时针旋转的角度</li><li>startAngle:沿长轴顺时针方向开始显示的角度</li><li>endAngle: 沿长轴顺时针结束显示的角度</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.ellipse(img,(<span class="number">220</span>,<span class="number">220</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">360</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h2><p><code>cv.polylines(img,pts,isClosed,color,thickness,lineType,shift)</code></p><ul><li>pts: 顶点数组</li><li>isClosed: 折线是否闭合</li></ul><p>要绘制多边形，首先需要顶点的坐标。将这些点组成形状为 ROWSx1x2 的数组，其中 ROWS 是顶点数，并且其类型应为 int32。在这里，我们绘制了一个带有四个顶点的黄色小多边形。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pts = np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line"><span class="comment">#reshape()函数改变数组的形状，且原始数据不变，参数需要满足乘积等于数组中的数据总数,-1表示未设定行数，由程序计算得出</span></span><br><span class="line">pts = pts.reshape((-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">cv.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 如果第三个参数为 False，将获得一条连接所有点的折线，而不是闭合形状。</p><hr><h2 id="填充多边形"><a href="#填充多边形" class="headerlink" title="填充多边形"></a>填充多边形</h2><p><code>fillPoly()</code>可以填充多个多边形</p><p><code>cv.fillPoly(img,pts,color,lineType,shift)</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pts = np.array([[<span class="number">40</span>, <span class="number">50</span>], [<span class="number">20</span>, <span class="number">30</span>], [<span class="number">70</span>, <span class="number">20</span>], [<span class="number">50</span>, <span class="number">10</span>]], np.int32)</span><br><span class="line">cv.fillPoly(img,[pts],(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="向图像添加文本"><a href="#向图像添加文本" class="headerlink" title="向图像添加文本:"></a>向图像添加文本:</h2><p><code>cv.putText(img,text,org,fontFace, fontScale, color,thickness,lineType,bottomLeftOrigin)</code></p><ul><li>text: 文本内容</li><li>org: 文本框的左下角位置坐标</li><li>fontFace: 字体</li></ul><table><thead><tr><th>常用字体</th><th></th></tr></thead><tbody><tr><td>cv.FONT_HERSHEY_SIMPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_DUPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_PLAIN</td><td></td></tr><tr><td>cv.FONT_HERSHEY_COMPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_TRIPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_COMPLEX_SMALL</td><td></td></tr><tr><td>cv.FONT_HERSHEY_SCRIPT_SIMPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_SCRIPT_COMPLEX</td><td></td></tr></tbody></table><ul><li>fontScale: 字体尺寸</li><li>bottomLeftOrigin： bool 类型，若为 True,org at lower left</li></ul><p>为了获得更好的外观，建议使用 lineType = cv.LINE_AA。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font = cv.FONT_HERSHEY_SIMPLEX</span><br><span class="line">cv.putText(img,<span class="string">&#x27;OpenCV&#x27;</span>,(<span class="number">10</span>,<span class="number">500</span>), font, <span class="number">4</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>,cv.LINE_AA)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变颜色空间</title>
      <link href="/2021/10/16/%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
      <url>/2021/10/16/%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p><strong>对于颜色转换，使用 cv 函数<code>cvtColor(input_img,flag)</code>，其中 flag 决定转换的类型</strong></p><span id="more"></span><h2 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h2><h3 id="BGR-gt-灰度转换"><a href="#BGR-gt-灰度转换" class="headerlink" title="BGR-&gt;灰度转换"></a>BGR-&gt;灰度转换</h3><p>flag: <code>cv.COLOR_BGR2GRAY</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment">#打开摄像头</span></span><br><span class="line">cap=cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;摄像头打开失败&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#逐帧捕获视频图像</span></span><br><span class="line">    tag,frame=cap.read()<span class="comment">#读取到帧，tag返回true,frame为读取到的图像对象</span></span><br><span class="line">    <span class="keyword">if</span> tag==<span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#将读取到的图像进行灰度处理</span></span><br><span class="line">    gray=cv.cvtColor(frame,cv.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment">#显示图像</span></span><br><span class="line">    cv.imshow(<span class="string">&quot;gray&quot;</span>,gray) <span class="comment"># 灰度处理后的图像</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;fram&#x27;</span>,frame) <span class="comment"># 原图像</span></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">5</span>)==<span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="BGR-gt-HSV"><a href="#BGR-gt-HSV" class="headerlink" title="BGR-&gt;HSV"></a>BGR-&gt;HSV</h3><p>flag: <code>cv.COLOR_BGR2HSV</code></p><p>转化方法同上，只需要修改<code>cvtColor(frame,COLOR_BGR2HSV)</code>即可</p><p><strong>注意</strong>: HSV 的色相范围为[0,179],饱和度范围为[0,255],值范围为[0,255]</p><h3 id="获取其他转换的类型标志"><a href="#获取其他转换的类型标志" class="headerlink" title="获取其他转换的类型标志"></a>获取其他转换的类型标志</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">flags=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="built_in">print</span>(flags)</span><br></pre></td></tr></table></figure><p>我们可以看到会打印出一些转换类型的标志，这里我只列举出一部分<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109281725423.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直方图增强实验</title>
      <link href="/2021/10/15/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C(%E4%BA%8C)/"/>
      <url>/2021/10/15/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p><strong>任意两幅灰度图像，显示它们的直方图，并将其中一幅的直方图传递给另一个图像，显示传递后的图像及其直方图</strong></p><span id="more"></span><hr><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>pycharm (python 解释器版本 3.8 ) + opencv</p><hr><h2 id="实验原理与问题分析"><a href="#实验原理与问题分析" class="headerlink" title="实验原理与问题分析"></a>实验原理与问题分析</h2><p>通过一个灰度映像函数，将原灰度直方图改造成所需要的直方图，即直方图规定化。</p><p>步骤:</p><ul><li>将图像进行直方图均衡化处理，求出原图像中每一个灰度级ri所对应的变换函数Si</li><li>对给定直方图做类似计算，得到理想图像中每一个灰度级Zi所对应的函数Vi</li><li>找出Vi近似于Si的像素点，并映射到Zi</li><li>求出目标图像的灰度概率密度Pi(Zi)</li></ul><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算直方图概率分布</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histNormalCalculate</span>(<span class="params">src</span>):</span></span><br><span class="line">    <span class="comment"># src图像的行数和列数</span></span><br><span class="line">    m,n = np.shape(src)</span><br><span class="line">    <span class="comment">#直方图</span></span><br><span class="line">    hist = np.zeros(<span class="number">256</span>,dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            hist[src[i,j]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> hist/(m*n)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算直方图累计概率分布</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histCalculate</span>(<span class="params">src</span>):</span></span><br><span class="line">    m,n = np.shape(src)</span><br><span class="line">    <span class="comment">#直方图</span></span><br><span class="line">    hist = np.zeros(<span class="number">256</span>,dtype=np.float32)</span><br><span class="line">    <span class="comment">#累积直方图</span></span><br><span class="line">    cumhist = np.zeros(<span class="number">256</span>,dtype=np.float32)</span><br><span class="line">    <span class="comment">#累积直方图概率</span></span><br><span class="line">    cumhistPro = np.zeros(<span class="number">256</span>,dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            hist[src[i,j]] += <span class="number">1</span></span><br><span class="line">    cumhist[<span class="number">0</span>] = hist[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">        cumhist[i] = cumhist[i-<span class="number">1</span>]+hist[i]</span><br><span class="line">    cumhistPro = cumhist/(m*n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cumhistPro</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#直方图规定化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histNormalize</span>(<span class="params">img1,img2</span>):</span></span><br><span class="line">    <span class="comment">#计算带匹配直方图</span></span><br><span class="line">    img1Pro = histCalculate(img1)</span><br><span class="line">    <span class="comment">#计算参考直方图</span></span><br><span class="line">    img2Pro = histCalculate(img2)</span><br><span class="line">    <span class="comment"># 匹配映射矩阵</span></span><br><span class="line">    correspondValue = np.zeros(<span class="number">256</span>,dtype=np.uint8)</span><br><span class="line">    <span class="comment">#直方图规定化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        diff = np.<span class="built_in">abs</span>(img1Pro[i]-img2Pro[i])</span><br><span class="line">        matchValue = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="comment"># 找到累积概率最接近的像素</span></span><br><span class="line">            <span class="keyword">if</span> np.<span class="built_in">abs</span>(img1Pro[i] - img2Pro[j]) &lt; diff:</span><br><span class="line">                diff = np.<span class="built_in">abs</span>(img1Pro[i]-img2Pro[j])</span><br><span class="line">                matchValue = j</span><br><span class="line">        correspondValue[i] = matchValue</span><br><span class="line">        <span class="comment"># 查找表</span></span><br><span class="line">    imgOut = cv.LUT(img1,correspondValue)</span><br><span class="line">    <span class="keyword">return</span> imgOut</span><br><span class="line">   <span class="comment"># 绘图</span></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,)</span><br><span class="line">plt.imshow(img1,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img1&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(img2,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img2&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">imgOut = histNormalize(img1,img2)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">plt.imshow(imgOut,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;imgOut&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">hist1 = histNormalCalculate(img1)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">plt.plot(hist1,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img1 hist ratio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">hist2 = histNormalCalculate(img2)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">plt.plot(hist2,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img2 hist ratio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">hist3 = histNormalCalculate(imgOut)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line">plt.plot(hist3,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;imgOut hist ratio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">plt.hist(img1.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.title(<span class="string">&quot;img1&#x27;s hist&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">plt.hist(img2.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.title(<span class="string">&quot;img2&#x27;s hist&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">plt.hist(imgOut.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.title(<span class="string">&quot;imgout&#x27;s hist&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整子图之间的间距</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110151414597.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像增强实验</title>
      <link href="/2021/10/15/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C(%E4%B8%80)/"/>
      <url>/2021/10/15/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p><strong>用多种图像增强方法完成如下人体骨骼核扫描图的增强任务</strong></p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110151944402.png"></p><p>从上到下从左到右分别为图(a)(b)(e)(f)(c)(d)(g)(h)：<br>(a)原图； (b)图(a)的拉普拉斯变换； (c)图(a)和图(b)相加得到的锐化图像；<br>(d)图(a)的 Sobel 处理； (e)用 5X5 的均值滤波平滑的 Sobel 图像；(f)由(c)和(e)相乘形成的掩蔽图像; (g)由(a)和(f)求和得到的锐化图像; (h)对(g)应用幂律变换得到的最后图像。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>pycharm (python 解释器版本 3.8 ) + opencv</p><hr><h2 id="实验原理与问题分析"><a href="#实验原理与问题分析" class="headerlink" title="实验原理与问题分析"></a>实验原理与问题分析</h2><p>运用图像平滑和梯度的相关知识(见之前发布的相关笔记)</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;Fig.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 拉普拉斯变换</span></span><br><span class="line">laplacian = cv2.Laplacian(img,cv2.CV_64F)</span><br><span class="line"><span class="comment"># sobel处理</span></span><br><span class="line">sobelx = cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobely = cv2.Sobel(img,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 取绝对值</span></span><br><span class="line">sobelx = np.uint8(np.absolute(sobelx))</span><br><span class="line">sobely = np.uint8(np.absolute(sobely))</span><br><span class="line"><span class="comment"># 对图像每个像素值进行二进制或运算</span></span><br><span class="line">sobelCom = cv2.bitwise_or(sobelx,sobely)</span><br><span class="line"><span class="comment"># add</span></span><br><span class="line">C = img+laplacian</span><br><span class="line"><span class="comment"># 均值滤波</span></span><br><span class="line">E = cv2.blur(sobelCom,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment"># ×</span></span><br><span class="line">F = C*E</span><br><span class="line">mina = np.<span class="built_in">min</span>(F)</span><br><span class="line">maxa = np.<span class="built_in">max</span>(F)</span><br><span class="line"><span class="comment">#print(mina,maxa)</span></span><br><span class="line">F = np.uint8(<span class="number">255</span>*(F-mina)/(maxa-mina))</span><br><span class="line"></span><br><span class="line">G = img+F</span><br><span class="line"><span class="comment"># 幂律变换</span></span><br><span class="line">H = cv2.<span class="built_in">pow</span>(G/<span class="number">255.0</span>,<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>),plt.imshow(img,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;A = original&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>),plt.imshow(laplacian,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;B = laplacian&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>),plt.imshow(C,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;C = add a and b&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>),plt.imshow(sobelCom,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;D = sobel&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>),plt.imshow(E,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;E = blur sobel&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>),plt.imshow(F,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;F = C*E&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>),plt.imshow(G,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;G = add a and f&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>),plt.imshow(H,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;H = mi lv&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110151947674.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像几何变换</title>
      <link href="/2021/10/08/%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
      <url>/2021/10/08/%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><strong>图像的几何变换是图像处理的基础之一，通过几何变换不仅可以产生一些特殊的效果，而且可以简化图像处理过程和分析程序。图像的几何变换最重要的特征是仅改变像素的位置，而不改变图像的像素值。图像的几何变换按性质可以分为图像的位置变换(平移、镜像、旋转)、图像的形状变换(放大、缩小、错切)等基本变换,以及图像的复合变换等。</strong></p><span id="more"></span><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>原理:</p><p>设原图像中的点 $p_{0}$($x_{0}$,$y_{0}$) 按一定比例缩放后，在新图像中的对应点为 P(x,y),则两者之间有如下对应关系</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081931471.png"></p><p><strong>注意</strong>: 如果图像在 x 轴和 y 轴方向缩放的比例不相同，则图像会产生<strong>几何畸变</strong>。</p><hr><p>代码:</p><p><code>cv.resize(src,dsize,dst,fx,fy,interpolation)</code></p><ul><li><p>src: 原图像</p></li><li><p>dsize: 目标图像尺寸，必须为<strong>整型</strong></p></li><li><p>dst: 目标图像</p></li><li><p>fx: 水平轴缩放比例</p></li><li><p>fy: 竖直轴缩放比例</p></li><li><p>interpolation: 插值方法</p><ul><li><code>INTER_NEAREST</code> 最邻近插值法</li><li><code>INTER_LINEAR</code> 双线性插值法(默认)</li><li><code>INTER_AREA</code> 基于局部像素的重采样</li><li><code>INTER_CUBIC</code> 基于 4×4 像素邻域的 3 次插值法</li><li><code>INTER_LANCZOS4</code> 基于 8×8 像素邻域的 Lanczos 插值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 这里将图像放大2倍</span></span><br><span class="line">res=cv.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 还可以通过另一种方式</span></span><br><span class="line"><span class="comment"># height,width=img.shape[:2]</span></span><br><span class="line"><span class="comment"># res=cv.resize(img,(width*2,height*2),cv.INTER_LINEAR)</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;resize&#x27;</span>,res)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081640790.png"></p><hr><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>原理:</p><p>设原图像中的点 $p_{0}$($x_{0}$,$y_{0}$) 经过平移变换后，在新图像中的对应点为 P(x,y),则两者之间有如下对应关系</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081950228.png"></p><hr><p>代码:</p><p><code>cv.wrapAffine(src,M,dsize,dst,flags,borderMode,borderValue)</code></p><ul><li><p>M: 变换矩阵</p></li><li><p>flags: 插值方法，同上述缩放变换中的表示</p></li><li><p>borderMode: 边界像素模式，默认为<code>BORDER_CONSTANT</code>,边界按常数填充</p><ul><li>cv.BORDER_CONSTANT: 添加有颜色的常数值边界，通过 borderValue 设置</li><li>cv.BORDER_REFLECT: 边界元素的镜像</li><li>cv.BORDER_REFLECT_101 或 cv.BORDER_DEFAULT 同上，只是处理方式稍有不同</li><li>cv.BORDER_REPLICATE: 重复最后一个元素</li><li>cv.BORDER_WRAP</li></ul></li><li><p>borderValue: 边界填充值，默认为 0，即填充黑色</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line"><span class="comment"># 图像的高度和宽度</span></span><br><span class="line">height,width=img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 使用numpy数组构造平移矩阵(数据类型为float32),设置x和y方向上平移量均为50</span></span><br><span class="line">M=np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">50</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])</span><br><span class="line">res=cv.warpAffine(img,M,(width,height))</span><br><span class="line">cv.imshow(<span class="string">&#x27;move&#x27;</span>,res)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081648866.png"></p><p>通过处理结果，我们发现由于没有扩大图像，平移后图像的部分数据会丢失。</p><hr><h2 id="镜像变换"><a href="#镜像变换" class="headerlink" title="镜像变换"></a>镜像变换</h2><p>图像的镜像变换分为水平镜像和垂直镜像。</p><p>代码:</p><p><code>cv.flip(src,dst,flip_mod)</code></p><ul><li>flip_mode: 图像镜像变换的方式<ul><li>flip_mode=0,表示沿 x 轴进行翻转</li><li>flip_mode&gt;0,表示沿 Y 轴进行翻转</li><li>flip_mode&lt;0,表示沿 x 和 y 轴进行翻转</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line"><span class="comment"># 沿x轴进行翻转</span></span><br><span class="line">dstx=cv.flip(img,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 沿y轴进行翻转</span></span><br><span class="line">dsty=cv.flip(img,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 沿xy轴进行翻转</span></span><br><span class="line">dstxy=cv.flip(img,-<span class="number">1</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dstx&#x27;</span>,dstx)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dsty&#x27;</span>,dsty)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dstxy&#x27;</span>,dstxy)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110071735691.png"></p><hr><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>原理:</p><p>设原图像中的点 $p_{0}$($x_{0}$,$y_{0}$)旋转$\theta$角后，在新图像中的对应点为 P(x,y),则两者之间有如下对应关系</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110082021030.png"></p><hr><p>代码:</p><p><code>cv.getRotationMatrix2D(center,angle,scale)</code></p><ul><li>center: 原图像的旋转中心</li><li>angle: 图像旋转角度，角度为正则表示逆时针旋转</li><li>scale: 缩放系数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取图像高度和宽度</span></span><br><span class="line">height,width=img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 设置旋转矩阵,30为旋转度数</span></span><br><span class="line">M=cv.getRotationMatrix2D((width/<span class="number">2</span>,height/<span class="number">2</span>),<span class="number">30</span>,<span class="number">1</span>)</span><br><span class="line">rotate=cv.warpAffine(img,M,(width,height),cv.INTER_LINEAR)</span><br><span class="line">cv.imshow(<span class="string">&#x27;rotate&#x27;</span>,rotate)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081705115.png"></p><p><strong>注意</strong>:</p><p>1.为避免丢失图像信息，可以通过<strong>设置旋转中心</strong>、<strong>缩放因子</strong>、<strong>调整窗口大小</strong>等方法</p><p>2.图像旋转后，因为坐标取值的不同，图像会出现空洞点，因此需要对空洞点进行填充处理，否则边缘将会出现锯齿影响图像质量。处理的方法可以通过<strong>插值</strong>处理。</p><hr><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>上面提到的平移和旋转都是仿射变换的特例。</p><p>原理:</p><p>在仿射变换中，原始图像中的所有平行线在输出图像中仍将平行。<br>为了找到变换矩阵 M，我们需要输入图像中的三个点及其在输出图像中的对应位置。<br>然后通过<strong>cv.getAffineTransform()<strong>找到一个</strong>2x3 变换矩阵 M</strong>，再将该矩阵将传递给**cv.warpAffine()**进行处理</p><hr><p>代码:</p><p><code>cv.getAffineTransform(src,dst)</code></p><ul><li>src: 原图中三个点所组成的矩阵,数据类型为<code>np.float32</code></li><li>dst: 目标图像中对应的 3 个点所组成的矩阵，数据类型为<code>np.float32</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=cv.imread(<span class="string">&#x27;change.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取图像的宽、高</span></span><br><span class="line">height,width=img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 原图像三个点和目标图像三个点的位置，数据类型为np.float32</span></span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">10</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">100</span>,<span class="number">250</span>]])</span><br><span class="line"><span class="comment"># 通过getAffineTransform()找到2×3的转换矩阵M</span></span><br><span class="line">M = cv.getAffineTransform(pts1,pts2)</span><br><span class="line"><span class="comment"># 将转换矩阵M传递给warpAffine()函数</span></span><br><span class="line">dst = cv.warpAffine(img,M,(width,height))</span><br><span class="line"><span class="comment"># 使用python绘图库绘制图像</span></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Input&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Output&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110082042140.png"></p><hr><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>空间坐标系中的三维物体或对象转变为二维图像的过程称为投影变换，根据投影中心(视点)与投影平面之间距离的不同，投影可以分为平行投影和透视投影。<br>透视投影即透视变换，透视投影的中心到投影平面之间的距离是有限的，具有<strong>透视缩小效应</strong>的特点，即三维物体或对象透视投影的大小与形体到投影中心的距离成反比。</p><p>原理:</p><p>对于透视变换，需要 3x3 变换矩阵。即使在转换后，直线也将保持直线。要找到此变换矩阵，需要在输入图像上有 4 个点，<br>在输出图像上需要相应的点。在这四个点中，其中<strong>三个不应共线</strong>。<br>然后可以通过函数 <strong>cv.getPerspectiveTransform()</strong> 找到变换矩阵。<br>再调用 <strong>cv.warpPerspective()</strong> 应用 3x3 转换矩阵</p><p><strong>关键</strong>:找到对应的转换矩阵 M</p><hr><p>代码:</p><p><code>cv.warpPerspective(src,M,dsize,dst,flags,borderMode,borderValue)</code></p><ul><li>M: 转换矩阵</li><li>flags: 插值方法，同上</li><li>borderMode: 边界像素模式,同上</li></ul><p>转换矩阵的获取:</p><p><code>cv.getPerspectiveTransform(src,dst)</code></p><ul><li>src: 原图像中 4 个点组成的矩阵，数据类型为<code>np.float32</code></li><li>dst: 目标图像中对应 4 个点组成的矩阵，数据类型为<code>np.float32</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;change.png&#x27;</span>)</span><br><span class="line">pts1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line">M = cv.getPerspectiveTransform(pts1,pts2)</span><br><span class="line">dst = cv.warpPerspective(img,M,(<span class="number">300</span>,<span class="number">300</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Input&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Output&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110082107328.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像形态学</title>
      <link href="/2021/10/05/%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%80%81%E5%AD%A6/"/>
      <url>/2021/10/05/%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%80%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>数学形态学是图像处理的重要工具，可用于获取<strong>图像边界</strong>、<strong>提取骨架</strong>、<strong>去除噪声</strong>和<strong>检测角点</strong>，其应用覆盖<br><strong>文字识别</strong>、<strong>视觉检测</strong>和<strong>医学图像处理</strong>等领域。</p><p>形态变换是一些基于图像形状的简单操作。形态学处理主要针对的是<strong>二值图像</strong>(在图像中任何像素点的灰度值只有 0 或 255)</p><p>两种基本的形态学算子是<strong>腐蚀</strong>和<strong>膨胀</strong>。</p><span id="more"></span><h2 id="结构元素-内核"><a href="#结构元素-内核" class="headerlink" title="结构元素(内核)"></a>结构元素(内核)</h2><p>在考察目标图像各部分之间的关系时，需要设计一种收集信息的“探针”，即结构元素。</p><ul><li><p>在图像中不断移动结构元素，就可以考察图像中各部间的关系。</p></li><li><p>结构元素的形状包括<strong>矩形</strong>、<strong>十字形</strong>、<strong>椭圆形和菱形</strong>等，如果结构元素长宽相等，矩形和椭圆形将退化为<strong>正方形</strong>和<strong>圆形</strong>。</p></li><li><p>一般来说，结构元素尺寸要明显小于目标图像的尺寸，选择不同形状和尺寸的结构元素可提取图像中的不同特征。</p></li><li><p>结构元素本身也是一个<strong>图像</strong>集合，对于结构元素可以指定一个原点，将其作为结构元素参与形态学运算的参考点。原点可包含在结构元素中，也可不包含在结构元素中。</p></li></ul><h2 id="腐蚀操作"><a href="#腐蚀操作" class="headerlink" title="腐蚀操作"></a>腐蚀操作</h2><p>原理:</p><p>腐蚀是一种最基本的数学形态学运算，对给定的目标图像 X 和结构元素 S，将 S 在图像上移动，则对于每一个当前位置 x 有</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051518952.png"></p><p>即 S 对 X 腐蚀的结果是<strong>S 完全包含在 X 中时 S 的原点位置的集合</strong>。</p><p>原始图像中的一个像素(无论是 1 还是 0)只有当内核下的所有像素都是 1 时才被认为是 1，否则它就会被侵蚀(变成 0)。<br>根据内核的大小，边界附近的所有像素都会被丢弃。<br>因此，前景物体的厚度或大小减小，或只是图像中的白色区域减小。它有助于去除小的白色噪声，分离两个连接的对象。</p><hr><p>代码:</p><p>OpenCV 中采用 <code>getStructuringElement()</code>和<code>erode()</code>函数实现结构元素的设定和图像腐蚀操作</p><p><code>cv2.getStructuringElement(eleType,ksize,point)</code></p><ul><li><p>eleType: 结构元素类型,OpenCV 中定义了 3 种基本结构元素形状</p><pre><code> · MORPH_RECT  矩形 . MORPH_CROSS  十字形 . MORPH_ELLIPSE 椭圆形</code></pre></li><li><p>ksize: 结构元素大小</p></li><li><p>point: 锚点(结构元素中心点)位置</p></li></ul><p><code>dst=cv2.erode(src,kernel,iterations)</code></p><ul><li>kernel: 卷积核</li><li>iterations: 迭代次数，默认为 1</li></ul><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;pic.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 通过getStructuringElement()设置结构元素</span></span><br><span class="line">kernel=cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 还可以通过np.ones()函数设置卷积核</span></span><br><span class="line"><span class="comment"># kernel=np.ones((3,3),np.uint8)</span></span><br><span class="line"><span class="comment"># 腐蚀</span></span><br><span class="line">erosion=cv.erode(img,kernel,iterations=<span class="number">2</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;erosion&#x27;</span>,erosion)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051536199.png"></p><p>对比处理结果我们发现原图像中的白色噪声被腐蚀掉了。</p><hr><h2 id="膨胀操作"><a href="#膨胀操作" class="headerlink" title="膨胀操作"></a>膨胀操作</h2><p>原理:</p><p>对给定的目标图像 X 和结构元素 S，将 S 在图像上移动，则对于每一个当前位置 x 有</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051610462.png"></p><p>即用 S 来膨胀 X 得到的集合是 <strong>$S^{v}$的平移与 X 至少有一个公共的非零元素相交时，S 的原点位置的集合</strong></p><p>($S^{v}$指 S 关于原点的映射)</p><p>与腐蚀操作相反(腐蚀虽然消除了白噪声，但也会压缩图像)，<strong>但并不是互为逆运算</strong>，<br>如果内核下至少有一个像素为“ 1”，则像素元素为“ 1”，图像就会膨胀。因此，它会增加图像中的白色区域或增加前景对象的大小。</p><hr><p>代码:</p><p><code>dst=cv.dilate(src,kernel,iterations)</code></p><ul><li>kernel: 卷积核</li><li>iterations: 迭代次数，默认为 1，进行一次膨胀</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;pic.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用numpy库生成卷积核</span></span><br><span class="line">kernel=np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion=cv.erode(img,kernel,iterations=<span class="number">2</span>)<span class="comment"># 腐蚀</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;erosion&#x27;</span>,erosion)</span><br><span class="line"><span class="comment"># 膨胀</span></span><br><span class="line">k=np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8) <span class="comment"># 使用3*3的卷积核</span></span><br><span class="line">dliate=cv.dilate(erosion,k)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dilate&#x27;</span>,dliate)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051621873.png"></p><p>这里我们将腐蚀过后的二值图像进行膨胀操作</p><hr><p><strong>由于腐蚀和膨胀并不是互为逆运算，所以它们可以结合使用。在腐蚀和膨胀两个基本运算的基础上，可以构造出形态学运算簇</strong></p><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><p>先对图像进行腐蚀然后膨胀其结果，称为开运算。对于消除噪音很有用</p><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pic2=cv.imread(<span class="string">&#x27;pic2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 开运算</span></span><br><span class="line">k=np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erode1=cv.erode(pic2,k,iterations=<span class="number">1</span>)</span><br><span class="line">dilate1=cv.dilate(erode1,k)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,pic2)</span><br><span class="line">cv.imshow(<span class="string">&#x27;open&#x27;</span>,dilate1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>或 <code>open= cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</code></p><hr><p>处理结果:<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051721256.png"></p><hr><h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><p>先对图像进行膨胀然后腐蚀其结果，称为闭运算。</p><p>在关闭前景对象内部的小孔或对象上的小黑点时很有用。</p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pic1=cv.imread(<span class="string">&#x27;pic1.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">k=np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"><span class="comment"># 闭运算</span></span><br><span class="line">dilate2=cv.dilate(pic1,k)</span><br><span class="line">erode2=cv.erode(dilate2,k,iterations=<span class="number">1</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,pic1)</span><br><span class="line">cv.imshow(<span class="string">&#x27;close&#x27;</span>,erode2)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>或 <code>close = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</code></p><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051725253.png"></p><hr><h2 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h2><p>图像膨胀与腐蚀运算之差</p><p>可以用形态学梯度来突出边缘，保留物体的边缘轮廓</p><hr><p><code>gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</code></p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051822445.png"></p><h2 id="顶帽"><a href="#顶帽" class="headerlink" title="顶帽"></a>顶帽</h2><p>原图与开运算之差</p><p><code>tophat = cv.morphologyEx(src, cv.MORPH_TOPHAT, kernel)</code></p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051801306.png"></p><h2 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h2><p>闭运算与原图之差</p><p><code>blackhat = cv.morphologyEx(src, cv.MORPH_BLACKHAT, kernel)</code></p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051805540.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像梯度</title>
      <link href="/2021/10/02/%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/"/>
      <url>/2021/10/02/%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>图像梯度是指图像某像素在x和y两个方向上的变化率(与相邻像素比较)，本质上即导数。</strong></p><span id="more"></span><h2 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h2><p>Sobel算子是高斯平滑加微分运算的联合运算，因此它更抗噪声</p><p><strong>Sobel算子常用模板</strong><br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021349749.png"></p><hr><p>代码:</p><p><code>dst=cv.Sobel(src,ddepth,dx,dy,ksize)</code></p><ul><li>ddepth: 输出图像的深度，若使用-1，则与原图像深度保持一致<code>numpy.uint8</code>,输出图像的深度必须大于等于原图像的深度</li><li>dx和dy分别表示导数方向为水平和竖直方向，0表示此方向不求导</li><li>kszie: Sobel算子的大小，如果ksize = -1，则使用3x3 Scharr滤波器，比3x3 Sobel滤波器具有更好的结果，必须为1，3，5，7</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;test.png&#x27;</span>,cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># 在x方向求导</span></span><br><span class="line">sobelx=cv.Sobel(img,cv.CV_8U,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 取绝对值，转回原来的uint8形式</span></span><br><span class="line">sobelx=cv.convertScaleAbs(sobelx)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;sobelx&#x27;</span>,sobelx)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>处理结果:<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021812235.png"></p><hr><p>从上面的处理结果我们会发现一个问题 :<strong>右边的边缘信息被忽略了.</strong></p><p>造成此种情况的原因在于<strong>黑色到白色的过渡被视为正斜率（具有正值），而白色到黑色的过渡被视为负斜率（具有负值），此时若设置输出图像的深度为<code>cv.CV_8U</code>或<code>numpy.uint8</code>,则所有的负值都会被截断为0(所建立的图像位数不够，会被截断为0),边界将会丢失。</strong></p><p><strong>解决方案</strong>: 如果要检测两个边缘，更好的选择是将输出数据类型保留为更高的形式，例如<code>cv.CV_16S</code>，<code>cv.CV_64F</code>等，取其绝对值，然后转换回<code>cv.CV_8U</code>。</p><p><strong>注意</strong>:取绝对值的步骤也同样需要，否则边缘也同样会丢失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;test.png&#x27;</span>,cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># CV_64F 表示输出图像的深度</span></span><br><span class="line"><span class="comment"># 在x方向求导</span></span><br><span class="line">sobelx=cv.Sobel(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>) </span><br><span class="line">sobelx=cv.convertScaleAbs(sobelx)</span><br><span class="line"><span class="comment"># 在y方向求导</span></span><br><span class="line">sobely=cv.Sobel(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobely=cv.convertScaleAbs(sobely)</span><br><span class="line"><span class="comment"># x和y方向按权求和</span></span><br><span class="line">sobelxy=cv.addWeighted(sobelx,<span class="number">0.5</span>,sobely,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;sobelx&#x27;</span>,sobelx)</span><br><span class="line">cv.imshow(<span class="string">&#x27;sobely&#x27;</span>,sobely)</span><br><span class="line">cv.imshow(<span class="string">&#x27;sobelxy&#x27;</span>,sobelxy)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021442542.png"></p><hr><h2 id="Scharr算子"><a href="#Scharr算子" class="headerlink" title="Scharr算子"></a>Scharr算子</h2><p>Scharr是对Sobel算子(使用小的卷积核求解梯度角度时)的优化。</p><p><strong>卷积核</strong><br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021417584.png"></p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;test.png&#x27;</span>,cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># x方向求导</span></span><br><span class="line">scharrx=cv.Scharr(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,scale=<span class="number">3</span>)</span><br><span class="line">scharrx=cv.convertScaleAbs(scharrx)</span><br><span class="line"><span class="comment"># y方向求导</span></span><br><span class="line">scharry=cv.Scharr(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,scale=<span class="number">3</span>)</span><br><span class="line">scharry=cv.convertScaleAbs(scharry)</span><br><span class="line"><span class="comment"># x和y方向按权求和</span></span><br><span class="line">scharrxy=cv.addWeighted(scharrx,<span class="number">0.5</span>,scharry,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;x&#x27;</span>,scharrx)</span><br><span class="line">cv.imshow(<span class="string">&#x27;Y&#x27;</span>,scharry)</span><br><span class="line">cv.imshow(<span class="string">&#x27;xy&#x27;</span>,scharrxy)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021433511.png"></p><hr><h2 id="laplacian算子"><a href="#laplacian算子" class="headerlink" title="laplacian算子"></a>laplacian算子</h2><p>拉普拉斯算子是一种各向同性的二阶微分算子，在(x，y)处的值定义为:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021931521.png"></p><p>当<strong>ksize=1</strong>时，拉普拉斯滤波器使用的卷积核:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021437477.png"></p><p>其他常用的拉普拉斯模板:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021620633.png"><br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021622506.png"></p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;test.png&#x27;</span>)</span><br><span class="line">laplacian=cv.Laplacian(img,cv.CV_64F)</span><br><span class="line">laplacian=cv.convertScaleAbs(laplacian)</span><br><span class="line">cv.imshow(<span class="string">&#x27;laplacian&#x27;</span>,laplacian)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021457598.png"></p><hr><h2 id="不同算子之间比较"><a href="#不同算子之间比较" class="headerlink" title="不同算子之间比较"></a>不同算子之间比较</h2><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>,cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># Sobel算子</span></span><br><span class="line">sobelx=cv.Sobel(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobelx=cv.convertScaleAbs(sobelx)</span><br><span class="line">sobely=cv.Sobel(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobely=cv.convertScaleAbs(sobely)</span><br><span class="line">sobelxy=cv.addWeighted(sobelx,<span class="number">0.5</span>,sobely,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># Scharr算子</span></span><br><span class="line">scharrx=cv.Scharr(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,scale=<span class="number">3</span>)</span><br><span class="line">scharrx=cv.convertScaleAbs(scharrx)</span><br><span class="line">scharry=cv.Scharr(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,scale=<span class="number">3</span>)</span><br><span class="line">scharry=cv.convertScaleAbs(scharry)</span><br><span class="line">scharrxy=cv.addWeighted(scharrx,<span class="number">0.5</span>,scharry,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># Laplacian算子</span></span><br><span class="line">laplacian=cv.Laplacian(img,cv.CV_64F)</span><br><span class="line">laplacian=cv.convertScaleAbs(laplacian)</span><br><span class="line"></span><br><span class="line">res=np.hstack((img,sobelxy,scharrxy,laplacian))</span><br><span class="line">cv.imshow(<span class="string">&#x27;all&#x27;</span>,res)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>对比:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021507528.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像平滑</title>
      <link href="/2021/09/30/%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91/"/>
      <url>/2021/09/30/%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91/</url>
      
        <content type="html"><![CDATA[<p><strong>图像平滑是一种区域增强算法，在图像产生、传输和复制的过程中，会因为多方面原因而产生噪声(某一像素与周围像素点相比有明显不同)或丢失数据，因而图像的质量会降低。此时就需要对图像进行一定的增强处理，以降低图像质量带来的影响</strong></p><span id="more"></span><h2 id="图像噪声"><a href="#图像噪声" class="headerlink" title="图像噪声"></a>图像噪声</h2><p>图像噪声使得图像模糊，甚至淹没图像特征，造成分析困难。</p><p>常见的噪声分类:</p><ul><li>产生原因: 外部噪声、内部噪声</li><li>统计特征: 平稳噪声 非平稳噪声</li><li>幅度分布: 高斯噪声 椒盐噪声</li><li>噪声频谱: 白噪声 1/f 噪声</li><li>噪声与信号之间的关系: 加性噪声 乘性噪声</li></ul><hr><h2 id="模板卷积"><a href="#模板卷积" class="headerlink" title="模板卷积"></a>模板卷积</h2><p>模板操作是图像处理中常用的一种邻域运算方式，主要有<strong>卷积</strong>和<strong>相关</strong>操作。</p><ul><li><p>模板:</p><p>常用矩阵表示，可以是一幅图像、一个滤波器或一个窗口，定义了参与运算的中心元素和邻域元素的相对位置及相关系数。<br>模板的中心元素(原点)表示将要处理的元素，一般取模板中心点，也可以根据需要选取非中心点。</p></li><li><p>模板卷积(或相关):</p><p>指模板与图像进行卷积(或相关)运算，是一种线性滤波，其输出像素是输入邻域像素的线性加权和。</p></li><li><p>卷积核:</p><p>模板卷积中的模板又称为卷积核，其元素称为卷积系数、模板系数或加权系数，其大小及排列顺序决定了对图像进行邻域处理的类型。</p></li></ul><p>卷积运算前需要将模板绕模板中心旋转 180°，其余运算过程与模板运算过程一致，因而统称模板卷积。</p><p>模板操作需要注意的两个问题:</p><ul><li><p>图像边界问题</p><p>当模板原点移至图像边界时，部分模板系数可能在原图像中找不到与之对应的像素。</p><p>解决方法:</p><p>1.不做处理</p><p>2.扩充图像</p><p>可以复制原图像边界像素或利用常数来填充扩充的像素边界</p></li><li><p>计算结果可能超出灰度范围</p></li></ul><hr><h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p>原理: 用一个像素邻域平均值作为滤波结果，此时滤波器模板的所有系数取值均为 1，仅获取内核区域下所有像素的平均值，并替换中心元素，为保证输出像素值不越界，邻域平均的卷积核系数之和为 1</p><hr><p>计算思路:</p><p>例如下图中，我们要计算红色点经过均值滤波后的像素值，蓝色区域 3×3 的矩阵为核，采用核处理后，红色点的像素值=<strong>(100+210+123+123+220+231+45+21+32)/9</strong></p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301159958.png"></p><hr><p>均值滤波常用的一个 3×3 的 Box 模板(还有 5×5 等等),Box 模板中加权系数均相同，邻域中各像素对平滑结果的影响相同。</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301137811.png"></p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">blur=cv.blur(img,(<span class="number">3</span>,<span class="number">3</span>)) <span class="comment">#(3×3)为核大小</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;blur&#x27;</span>,blur)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292310023.png"></p><hr><h2 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h2><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">box=cv.boxFilter(img,-<span class="number">1</span>,(<span class="number">3</span>,<span class="number">3</span>),normalize=<span class="literal">True</span>) <span class="comment"># -1 表示颜色通道一致，(3,3)表示卷积核的大小 normalize表示归一化，如果选择归一化，则和均值滤波是一样的</span></span><br><span class="line">box2=cv.boxFilter(img,-<span class="number">1</span>,(<span class="number">3</span>,<span class="number">3</span>),normalize=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># normalize为false，不进行归一化处理，此时模板内像素进行处理时可能会发生越界的情况(即超过最大的像素值255),越界的情况会直接取最大值255</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;boxfilter1&#x27;</span>,box)</span><br><span class="line">cv.imshow(<span class="string">&#x27;box2&#x27;</span>,box2)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果(进行归一化):</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292336627.png"></p><p>处理结果(不进行归一化):</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292315254.png"></p><hr><h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p>原理:</p><ul><li>高斯模板是通过对二维高斯函数进行采样(高斯模糊的卷积核里的数值满足高斯分布)、量化并归一化得到的，它考虑了邻域像素位置的影响，距离当前被平滑像素越近的点，加权系数越大，将加权平均值作为中心像素的输出结果。</li><li>加权的目的在于减轻平滑过程中造成的图像模糊</li><li>高斯模糊对于从图像中去除高斯噪声非常有效</li></ul><p>高斯滤波常用的一个 3×3 模板</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301226649.png"></p><hr><p>代码:</p><p><strong>cv.GaussianBlur(src,ksize,sigmaX,sigmaY)</strong></p><ul><li>ksize:卷积核大小</li><li>sigmaX:X 方向标准偏差</li><li>sigmaY:Y 方向标准偏差</li></ul><p>如果仅指定 sigmaX，则将 sigmaY 与 sigmaX 相同。如果两个都为零，则根据内核大小进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">gauss=cv.GaussianBlur(img,(<span class="number">7</span>,<span class="number">7</span>),<span class="number">0</span>)<span class="comment"># (7,7)为卷积核大小</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;gauss&#x27;</span>,gauss)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292322264.png"></p><hr><h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p>中值滤波是一种非线性滤波，它能在滤除噪声的同时很好地保持图像边缘。</p><p>原理: 以某像素为中心的窗口内所有像素的灰度按从小到大排序，取排序结果的中间值作为该像素的灰度值。</p><hr><p>计算思路:</p><p>例如我们以 220 为中心选取了一个 3×3 的窗口，此时对窗口内所有像素按灰度大小进行排序，取中间值 123 作为中值滤波后的像素值。<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301306976.png"></p><hr><p>代码:</p><p><strong>cv.medianBlur(src,ksize)</strong></p><ul><li>ksize:表示卷积核大小，必须是一个<strong>大于 1 的奇数</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">media=cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;media&#x27;</span>,media)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292326292.png"></p><hr><h2 id="上述滤波处理对比"><a href="#上述滤波处理对比" class="headerlink" title="上述滤波处理对比"></a>上述滤波处理对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">blur=cv.blur(img,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">gauss=cv.GaussianBlur(img,(<span class="number">7</span>,<span class="number">7</span>),<span class="number">0</span>)</span><br><span class="line">media=cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">res=np.hstack((img,blur,gauss,media)) <span class="comment"># 水平拼接所有图像</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;all&#x27;</span>,res)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301319618.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像阈值</title>
      <link href="/2021/09/28/%E5%9B%BE%E5%83%8F%E9%98%88%E5%80%BC/"/>
      <url>/2021/09/28/%E5%9B%BE%E5%83%8F%E9%98%88%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><strong>阈值又叫临界值，是指一个效应能够产生的最低值或最高值</strong></p><span id="more"></span><h2 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h2><p><code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code></p><ul><li><p>src: 输入图，注意只能是单通道图像，通常使用灰度图</p></li><li><p>ret: 返回阈值</p></li><li><p>dst: 输出图</p></li><li><p>thresh: 阈值</p></li><li><p>maxval: 当图像像素值超过了阈值(或者小于阈值，根据 type 来决定)所赋予的值</p></li><li><p>type: 二值化操作的类型，包括五种类型:</p><p><code>cv2.THRESH_BINARY</code>:超过阈值部分取 maxval(最大值)，低于阈值部分取 0</p><p><code>cv.THRESH_BINARY_INV</code>:低于阈值部分取 maxval(最大值)，超过阈值部分取 0</p><p><code>cv.THRESH_TRUNC</code>: 大于阈值部分设为阈值，否则不变</p><p><code>cv.THRESH_TOZERO</code>: 大于阈值部分不变，否则为 0</p><p><code>cv2.THRESH_TOZERO_INV</code>: 低于阈值部分不变，否则为 0</p></li></ul><hr><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 图像灰度处理</span></span><br><span class="line">gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 简单阈值处理</span></span><br><span class="line">ret,dst1=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,dst2=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,dst3=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,dst4=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,dst5=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,gray)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst1&#x27;</span>,dst1)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst2&#x27;</span>,dst2)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst3&#x27;</span>,dst3)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst4&#x27;</span>,dst4)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst5&#x27;</span>,dst5)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>不同简单阈值类型的对比</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109281837906.png"></p><hr><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>如果图像在不同区域具有不同的光照条件。在这种情况下，自适应阈值效果更好。算法基于像素周围的小区域确定像素的阈值，因此，对于同一图像的不同区域，我们获得了不同的阈值，<br>这为光照度变化的图像提供了更好的结果。</p><hr><p><code>dst=cv2.adaptiveThreshold(src,maxValue,adaptiveMethod,thresholdType,blockSize,C)</code></p><ul><li><p>src: 输入图，注意只能是单通道图像，通常使用灰度图</p></li><li><p>dst: 输出图</p></li><li><p>maxValue: 当图像像素值超过了阈值(或者小于阈值，根据 thresholdType 来决定)所赋予的值</p></li><li><p>adaptiveMethd: 决定阈值是如何计算的</p><p><code>cv2.ADAPTIVE_THRESH_MEAN_C</code>:阈值是邻近区域的平均值减去常数<strong>C</strong>。</p><p><code>cv2.ADAPTIVE_THRESH_GAUSSIAN_C</code>:阈值是邻域值的高斯加权总和减去常数<strong>C</strong></p></li><li><p>thresholdType:</p><p><code>cv2.THRESH_BINARY</code>:超过阈值部分取 maxval(最大值)，低于阈值部分取 0</p><p><code>cv.THRESH_BINARY_INV</code>:低于阈值部分取 maxval(最大值)，超过阈值部分取 0</p></li><li><p>blockSize: 确定附近区域的大小</p></li><li><p>C:是从邻域像素的平均或加权总和中减去的一个常数</p></li></ul><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 图像灰度处理</span></span><br><span class="line">gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 自适应阈值处理</span></span><br><span class="line">dst=cv.adaptiveThreshold(gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">25</span>,<span class="number">5</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,gray)</span><br><span class="line">cv.imshow(<span class="string">&#x27;adaptive&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109281947330.png"></p><hr><h2 id="Otsu-阈值法"><a href="#Otsu-阈值法" class="headerlink" title="Otsu 阈值法"></a>Otsu 阈值法</h2><p>二值化操作类型:</p><p><code>THRESH_OTSU</code>: 使用 Otsu 算法选取最优阈值，可与上述任何一种 type 组合</p><p>例如: <code>type=THRESH_OTSU+THRESH_BINARY</code> , 即先用 Otsu 算法自动计算出阈值，然后利用该阈值采用<code>THRESH_BINARY</code>规则,默认为<code>THRESH_BINARY</code></p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 图像灰度处理</span></span><br><span class="line">gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># Otsu阈值</span></span><br><span class="line">ret,dst=cv.threshold(gray,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_OTSU+cv.THRESH_BINARY)</span><br><span class="line"><span class="built_in">print</span>(ret) <span class="comment">#控制台打印算法选取的最优阈值</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,gray)</span><br><span class="line">cv.imshow(<span class="string">&#x27;Otsu&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109282017226.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建指南</title>
      <link href="/2021/09/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2021/09/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境部署"><a href="#1-环境部署" class="headerlink" title="1.环境部署"></a>1.环境部署</h1><h2 id="1-1-Nodejs-安装"><a href="#1-1-Nodejs-安装" class="headerlink" title="1.1 Nodejs 安装"></a>1.1 Nodejs 安装</h2><ul><li><p>进入官网选择对应的系统下载<br><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p></li><li><p>下载完成之后，要配置一下环境变量</p></li><li><p>配置好环境变量之后，进入 cmd 命令行窗口输入</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v <span class="comment">#npm为包管理工具</span></span><br></pre></td></tr></table></figure><ul><li>显示安装版本号，即安装成功。</li></ul><span id="more"></span><h2 id="1-2-Git-安装"><a href="#1-2-Git-安装" class="headerlink" title="1.2 Git 安装"></a>1.2 Git 安装</h2><ul><li>进入官网安装对应系统版本 <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li><li>配置系统环境变量</li><li>打开 git bash 输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -version</span><br></pre></td></tr></table></figure><ul><li><p>显示版本号即安装成功</p></li><li><p>后续进行相关的 git 补充配置</p></li></ul><h2 id="1-3-Hexo-安装"><a href="#1-3-Hexo-安装" class="headerlink" title="1.3 Hexo 安装"></a>1.3 Hexo 安装</h2><p>这里我们需要通过阿里的 cnpm 管理器进行安装，速度会快一点</p><hr><ul><li>这里通过 git-bash 窗口(cmd 也可以，注意一下以管理员的身份)安装 cnpm</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>查看 cnpm 版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><ul><li>安装 hexo 框架</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>安装结束之后，查看一下 hexo 版本，显示则成功,如果提示 hexo 无法识别的指令，需要配置一下环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="1-4-Hexo-配置"><a href="#1-4-Hexo-配置" class="headerlink" title="1.4 Hexo 配置"></a>1.4 Hexo 配置</h2><ul><li>下面我们需要创建一个博客的根目录，手动或者命令行都可以</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog #注意目录的路径,blog是文件名</span><br></pre></td></tr></table></figure><ul><li>初始化目录,初始化结束后 hexo 会自动生成所需的文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>启动本地博客服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动成功之后，会提供本地的访问地址，默认是 <a href="http://localhost:4000/">http://localhost:4000</a></p><hr><h2 id="1-5-部署到-github-上"><a href="#1-5-部署到-github-上" class="headerlink" title="1.5 部署到 github 上"></a>1.5 部署到 github 上</h2><ul><li>准备工作</li></ul><hr><p>登录 github，新建一个仓库，仓库名必须是:用户名.github.io ，并且需要初始化一个 Readme 文件。</p><hr><p>建好仓库之后，在 Setting 设置中找到 GitHub Pages 选项，可以找到 GitHub Pages 为我们创建好的域名</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171516892.png"></p><hr><ul><li>使用 ssh-keygen 生成私钥和公钥，会生成一个 id_ras.pub 文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa <span class="comment">#git bash命令行输入，注意这里要配置好git环境</span></span><br></pre></td></tr></table></figure><hr><p>找到 github 上 SSH and GPG keys 选项，点击 New SSH key</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171501849.png"></p><hr><p>将刚刚生成的公钥 id_ras.pub 文件里面的内容复制到 key 里面(记事本打开)</p><hr><ul><li>进入 bash 输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>第一次会让你进行 yes 确认，确认之后看到的是自己的用户名就成功了</p><hr><ul><li>本地 PC 完成推送部署<br>打开生成的博客根目录 blog 下的 hexo 配置文件 _config.yml,进行以下配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repo: git@github.com:用户名/仓库名.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure><p>这里要<strong>注意缩进</strong>，GitHub 的 branch 设置现在默认是 main，设置仓库分支的时候要设置成 master</p><ul><li>安装部署插件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><hr><ul><li>部署完成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>然后打开 github 分配的域名进行查看(之前 github pages 选项里面)</p><h1 id="2-Hexo-基本操作"><a href="#2-Hexo-基本操作" class="headerlink" title="2.Hexo 基本操作"></a>2.Hexo 基本操作</h1><ul><li>初始化博客</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>新建文章</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;文章名字&quot;</span><br></pre></td></tr></table></figure><p>新建文章会自动生成一个 md 文件,可以进行相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称</span><br><span class="line">date:  #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories:  #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，单个标签 -tag1 注意冒号:后面有个空格</span><br><span class="line">description: 摘要</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>新建页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;页面名字&quot;</span><br></pre></td></tr></table></figure><p>会在 source 文件夹下生成一个文件夹，其中 index.md 为页面内容</p><ul><li>清除缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><ul><li>生成静态页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><ul><li>启动本地服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>指定其他端口号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 端口号</span><br></pre></td></tr></table></figure><ul><li>部署</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="3-Hexo-进阶"><a href="#3-Hexo-进阶" class="headerlink" title="3.Hexo 进阶"></a>3.Hexo 进阶</h1><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>在 Hexo <a href="https://hexo.io/themes">主题官网</a>找到需要的主题，通过 git 克隆到本地仓库</p><p>修改 hexo 根目录下的_config.yml 中的 <code>theme: landscape</code> 换成需要的主题名</p><p>如<code>theme: Cxo</code></p><hr><h2 id="PicGo-GitHub-配置-CDN-图床"><a href="#PicGo-GitHub-配置-CDN-图床" class="headerlink" title="PicGo+GitHub 配置 CDN 图床"></a>PicGo+GitHub 配置 CDN 图床</h2><ul><li>创建 GitHub 图床仓库，仓库设置为 public，需要有初始化文件</li><li>获取 GitHub token 值</li></ul><p>step1:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171558349.png"></p><p>step2:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171558394.png"></p><p>step3:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171558695.png"></p><p>step4:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171558200.png"></p><p>step5:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171604099.png"></p><p>之后会跳转到有 token 的页面，将 token 的值复制记录下来(<strong>只出现一次</strong>)用于 PicGo 绑定 GitHub</p><hr><ul><li><p>绑定 GitHub 图床</p><p>首先下载 PicGo 软件 <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p></li></ul><hr><p>然后设置 GitHub 图床</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171612012.png"></p><hr><ul><li>PicGo 注意事项</li></ul><p><strong>仓库名不要有空格</strong></p><p><strong>图片名字不要带特殊字符</strong></p><p><strong>建议开启时间戳重命名，在 PicGo 设置中</strong></p><p><strong>上传图片间歇太短，在 PicGo 设置中关闭 Server</strong></p><ul><li>更多内容参考</li></ul><p>PicGo 操作手册 <a href="https://picgo.github.io/PicGo-Doc/zh/guide">https://picgo.github.io/PicGo-Doc/zh/guide</a></p><h1 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h1><ul><li>更多相关操作访问<a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2021/09/16/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/09/16/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>Welcome to Git Introduce,this article will be updated continuously</strong></p><h1 id="Git-介绍"><a href="#Git-介绍" class="headerlink" title="Git 介绍"></a>Git 介绍</h1><p>Git 是一款流行的代码版本管理工具，Git 是分布式版本控制系统，区别于 SVN 和 CSV 这样的集中式版本控制系统。</p>   <span id="more"></span><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><h2 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;url&gt; <span class="comment">#从远程仓库克隆代码</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">#初始化本地git仓库</span></span><br></pre></td></tr></table></figure><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="comment">#查看本地所有的分支</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r <span class="comment">#查看远程所有的分支</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a <span class="comment">#查看所有分支(本地和远程)</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged <span class="comment">#查看所有分支已合并到当前分支的分支</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;new-branch&gt; <span class="comment">#新建分支</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt; <span class="comment">#删除本地分支</span></span><br></pre></td></tr></table></figure><h2 id="本地更改"><a href="#本地更改" class="headerlink" title="本地更改"></a>本地更改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment">#查看当前分支的状态</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="comment">#查看跟踪文件的变更</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="comment">#将所有变更的文件添加到暂存区</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a <span class="comment">#提交所有本地更改</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;xxx&quot;</span> <span class="comment">#将已添加至暂存区的文件执行提交，并进行描述xxx</span></span><br></pre></td></tr></table></figure><h2 id="服务端提交"><a href="#服务端提交" class="headerlink" title="服务端提交"></a>服务端提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">#本地与服务器端进行同步</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="comment">#将本地分支推送到服务器端</span></span><br></pre></td></tr></table></figure><h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">#查看提交历史</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n <span class="comment">#显示n行日志,n为整数</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;commit&gt; <span class="comment">#查看提交日志和相关变动文件</span></span><br></pre></td></tr></table></figure><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt; <span class="comment">#删除文件</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r &lt;directory&gt; <span class="comment">#删除指定目录下的文件</span></span><br></pre></td></tr></table></figure><h2 id="撤销命令"><a href="#撤销命令" class="headerlink" title="撤销命令"></a>撤销命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit&gt; <span class="comment">#将当前版本重置为某一个提交状态，代码不变</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt; <span class="comment">#撤销提交</span></span><br></pre></td></tr></table></figure><h2 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list <span class="comment">#列出当前Git配置</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
