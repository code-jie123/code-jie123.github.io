<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统调度算法</title>
      <link href="/2022/01/02/%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/02/%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="相关参数准则"><a href="#相关参数准则" class="headerlink" title="相关参数准则"></a>相关参数准则</h2><ul><li><p>周转时间：从作业提交到完成作业的时间</p><p>${周转时间=作业完成时间-作业提交时间}$</p></li><li><p>平均周转时间：多个作业周转时间的平均值</p><p>${平均周转时间=(作业1的周转时间+…+作业n的周转时间)/n}$</p></li><li><p>带权周转时间：作业周转时间与作业实际运行时间的比值</p><p>${带权周转时间=\frac {作业的周转时间}{作业实际运行时间}}$</p></li><li><p>平均带权周转时间</p><p>${平均带权周转时间=(作业1的带权周转时间+…+作业n的带权周转时间)/n}$</p></li></ul><h2 id="先来先服务-FCFS-调度算法"><a href="#先来先服务-FCFS-调度算法" class="headerlink" title="先来先服务(FCFS)调度算法"></a>先来先服务(FCFS)调度算法</h2><p>FCFS 调度算法是一种最简单的调度算法，它既可用于作业调度，又可用于进程调度。</p><p>算法思想：</p><ul><li><p>在作业调度中，算法每次从后备队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p></li><li><p>在进程调度中，算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，直到运行完成或因为某种事件阻塞才释放处理机。</p></li></ul><p>例如系统中有 4 个作业，它们的提交时间分别为 8，8.4，8.8，9；运行时间分别为 2，1，0.5，0.2，系统采用 FCFS 调度算法，性能参数如下：</p><table><thead><tr><th>作业号</th><th>提交时间</th><th>运行时间</th><th>开始时间</th><th>等待时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8</td><td>2</td><td>8</td><td>0</td><td>10</td><td>2</td><td>1</td></tr><tr><td>2</td><td>8.4</td><td>1</td><td>10</td><td>1.6</td><td>11</td><td>2.6</td><td>2.6</td></tr><tr><td>3</td><td>8.8</td><td>0.5</td><td>11</td><td>2.2</td><td>11.5</td><td>2.7</td><td>5.4</td></tr><tr><td>4</td><td>9</td><td>0.2</td><td>11.5</td><td>2.5</td><td>11.7</td><td>2.7</td><td>13.5</td></tr></tbody></table><p>注意：</p><ul><li>FCFS 调度算法属于不可抢占式算法</li><li>算法简单，但效率低</li><li>对长作业有利，对短作业不利。不能作为分时系统和实时系统的主要调度策略。</li><li>有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业</li></ul><hr><h2 id="短作业优先-SJF-调度算法"><a href="#短作业优先-SJF-调度算法" class="headerlink" title="短作业优先(SJF)调度算法"></a>短作业优先(SJF)调度算法</h2><p>算法思想：</p><ul><li>短作业优先调度算法从后备队列中选择一个或若干个运行时间最短的作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</li><li>短进程优先调度算法从就绪队列中选择一个运行时间最短的进程，将处理机分配给它并立即执行，直到运行结束或发生某事件而阻塞时，才释放处理机。</li></ul><p>例如系统中有 4 个作业，它们的提交时间分别为 8，8.4，8.8，9；运行时间分别为 2，1，0.5，0.2，系统采用 SJF 调度算法，性能参数如下：</p><table><thead><tr><th>作业号</th><th>提交时间</th><th>运行时间</th><th>开始时间</th><th>等待时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8</td><td>2</td><td>8</td><td>0</td><td>10</td><td>2</td><td>1</td></tr><tr><td>2</td><td>8.4</td><td>1</td><td>10.7</td><td>2.3</td><td>11.7</td><td>3.3</td><td>3.3</td></tr><tr><td>3</td><td>8.8</td><td>0.5</td><td>10.2</td><td>1.4</td><td>10.7</td><td>1.9</td><td>3.8</td></tr><tr><td>4</td><td>9</td><td>0.2</td><td>10</td><td>1</td><td>10.2</td><td>1.2</td><td>6</td></tr></tbody></table><p>注意：</p><ul><li>SJF 算法对长作业不利，由于调度程序总是优先调度那些短作业，导致长作业长期不被调度(“饥饿现象”)</li><li>SJF 算法不能保证紧迫性作业被及时处理</li><li>SJF 算法的平均等待时间、平均周转时间最少</li></ul><hr><h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><p>优先级调度算法既可用于作业调度，又可以用于进程调度。</p><p>算法思想：</p><ul><li>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最高的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</li><li>在进程调度中，优先级调度算法从就绪队列中选择优先级最高的进程，将处理机分配给它并运行。</li></ul><p>注意：</p><ul><li><p>优先级调度算法可分为：可抢占式优先级调度算法和非抢占式优先级调度算法。</p><ul><li>可抢占式优先级调度算法：当一个进程在处理机上运行时，若有某个优先级更高的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给优先级更高的进程。</li><li>非抢占式优先级调度算法：当一个进程在处理机上运行时，即使有某个优先级更高的进程进入就绪队列，仍然运行正在运行的进程，直到运行完成或发生事件阻塞让出处理机。</li></ul></li><li><p>进程优先级的设置分为：静态优先级和动态优先级。</p><ul><li>静态优先级：优先级在创建进程时确定，且在进程的整个运行期间保持不变。</li><li>动态优先级：在进程的运行过程中，根据进程情况变化，动态调整优先级。动态调整的依据有<strong>进程占用 CPU 的时间</strong>、<strong>就绪进程等待 CPU 的时间</strong>等。</li></ul></li><li><p>进程优先级设置原则：</p><ol><li> 系统进程&gt;用户进程</li><li> 交互型进程&gt;非交互型进程(前台进程&gt;后台进程)</li><li> I/O 型进程&gt;计算型进程(I/O 型：频繁使用 I/O 设备，计算型：频繁使用 CPU)</li></ol></li></ul><h2 id="高响应比调度算法"><a href="#高响应比调度算法" class="headerlink" title="高响应比调度算法"></a>高响应比调度算法</h2><p>主要用于作业调度，是对 FCFS 算法和 SJF 算法的一种综合，同时考虑了每个作业的等待时间和运行时间。</p><p>算法思想：<br>在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，选出响应比最高的作业投入运行。</p><p>${响应比=\frac {等待时间+运行时间}{运行时间} }$</p><p>注意：</p><ul><li>作业的等待时间相同时，运行时间越短，响应比越高，有利于短作业</li><li>运行时间相同时，等待时间越长，响应比越高，相当于执行的是 FCFS 算法</li><li>对于长作业，作业的响应比随等待时间的增加而提高，获得处理机的机会就越大，克服了”饥饿“状态，兼顾了长作业。</li></ul><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p>时间片轮转调度算法主要用于分时系统。</p><p>算法思想：</p><p>系统将所有就绪进程按照到达时间的先后次序排成一个队列，调度程序选择就绪队列中的第一个进程执行，即先来先服务的原则，但进程仅能运行一个时间片，如 100ms。在使用完一个时间片后，即使进程还未完成任务，也必须释放处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等待再次运行。</p><p>注意：</p><ul><li>时间片的大小对系统性能的影响很大，若时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为 FCFS 算法。若时间片很小，则处理机在进程间频繁地切换，处理机的开销增大。</li><li>时间片大小的选择原则：系统的响应时间、就绪队列中进程的数目、系统的处理能力</li></ul><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。</p><p>算法思想：</p><ul><li>设置多个就绪队列，并为多个队列赋予不同的优先级，第 1 级队列的优先级最高，第 2 级队列优先级次之，其余队列的优先级逐次降级。</li><li>赋予各个队列中进程执行时间片的大小各不相同。在优先级越高的队列中，每个进程的时间片就越小。</li><li>一个新的进程进入内存后，首先将它放入第 1 级队列的末尾，按照 FCFS 原则排队等待调度。<br>当轮到该进程执行时，如果它能在时间片内执行完成，便可撤离系统。否则的话，调度程序便将该进程调度到第 2 级队列的末尾，再同样按照 FCFS 原则等待调度执行，如此下去，当一个长进程从第 1 级队列降到第 n 级队列后，在第 n 级队列便采用时间片轮转方式运行。</li><li>仅当第 1 级队列为空时，调度程序才调度第 2 级队列中的进程运行。仅当第 1~(i-1)级队列均为空时，才会调度第 i 级队列中的进程运行。</li><li>若处理机正在执行第 i 级队列中的某进程，这时又有新进程进入优先级更高的队列，则此时新进程将抢占正在运行进程的处理机，调度程序会将正在运行的进程放回第 i 级队列的末尾，把处理机分配给新到的更高优先级的进程。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202201022100490.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -算法 </tag>
            
            <tag> -操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="/2021/12/30/vue-axios/"/>
      <url>/2021/12/30/vue-axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios-特点"><a href="#axios-特点" class="headerlink" title="axios 特点"></a>axios 特点</h2><ul><li>基于 promise 的异步 ajax 请求库</li><li>支持请求/响应拦截器</li><li>支持请求取消</li><li>请求/响应数据转换</li><li>批量发送多个请求</li></ul><hr><h2 id="axios-安装引入"><a href="#axios-安装引入" class="headerlink" title="axios 安装引入"></a>axios 安装引入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="全局默认设置"><a href="#全局默认设置" class="headerlink" title="全局默认设置"></a>全局默认设置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.default.baseURL = <span class="string">&quot;http://localhost:8080&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="默认设置优先级"><a href="#默认设置优先级" class="headerlink" title="默认设置优先级"></a>默认设置优先级</h3><p>默认设置是可以被覆盖的，越往后，优先级越高</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line">axios.default.timeout = <span class="number">1000</span>; <span class="comment">//全局默认设置</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">2000</span>, <span class="comment">//实例默认设置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">instance</span><br><span class="line">  .get(<span class="string">&quot;/user&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">3000</span>, <span class="comment">//请求默认设置，生效</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="axios-常用请求方法"><a href="#axios-常用请求方法" class="headerlink" title="axios 常用请求方法"></a>axios 常用请求方法</h2><h3 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h3><p><code>axios.get(url,config)</code> config 可选</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(<span class="string">&quot;/user?id=123&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>通过配置参数的方式，params 中的参数会追加到 url 路径后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(<span class="string">&quot;/user&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">123</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h3><p><code>axios.post(url,data,config)</code> data,config 可选</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .post(<span class="string">&quot;/user&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;li&quot;</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>, <span class="comment">//请求数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="其它方式"><a href="#其它方式" class="headerlink" title="其它方式"></a>其它方式</h3><p><code>axios(config)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>, <span class="comment">//请求方式,默认get请求</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080&quot;</span>, <span class="comment">//请求路径</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="comment">//请求数据</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;s&quot;</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h3><p><code>axios.all(iterable)</code>实现发送多个请求，函数返回一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> get1 = axios.get(<span class="string">&quot;/user/123&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> get2 = axios.get(<span class="string">&quot;/user/123/n&quot;</span>);</span><br><span class="line"></span><br><span class="line">axios</span><br><span class="line">  .all([get1, get2])</span><br><span class="line">  .then(</span><br><span class="line">    <span class="comment">//axios.spread(callback)用于将结果数组展开</span></span><br><span class="line">    axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res1, res2);</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure><hr><h2 id="响应信息"><a href="#响应信息" class="headerlink" title="响应信息"></a>响应信息</h2><p>客户端在发出请求，服务端会响应客户端的请求，然后向客户端发送响应信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//服务器响应的数据</span></span><br><span class="line">    <span class="attr">data</span>: &#123; &#125;,</span><br><span class="line">    <span class="comment">//服务器响应的http状态码</span></span><br><span class="line">    <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="comment">//服务器返回的http状态信息</span></span><br><span class="line">    <span class="attr">statusText</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">    <span class="comment">//服务器响应中携带的headers</span></span><br><span class="line">    <span class="attr">headers</span>: &#123; &#125;,</span><br><span class="line">    <span class="comment">//axios进行的设置</span></span><br><span class="line">    <span class="attr">config</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;/user&quot;</span>).then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(resp.data);</span><br><span class="line">  <span class="built_in">console</span>.log(resp.status);</span><br><span class="line">  <span class="built_in">console</span>.log(resp.headers);</span><br><span class="line">  <span class="built_in">console</span>.log(resp.statusText);</span><br><span class="line">  <span class="built_in">console</span>.log(resp.config);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="创建-axios-实例对象"><a href="#创建-axios-实例对象" class="headerlink" title="创建 axios 实例对象"></a>创建 axios 实例对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;http//localhost:8080&quot;</span>, <span class="comment">//默认路径</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">//请求超时，单位ms</span></span><br><span class="line">  <span class="attr">headers</span>: &#123; <span class="string">&quot;X-Custom-Header&quot;</span>: <span class="string">&quot;foo&quot;</span> &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="通过-instance-发送请求"><a href="#通过-instance-发送请求" class="headerlink" title="通过 instance 发送请求"></a>通过 instance 发送请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">instance</span><br><span class="line">  .get(<span class="string">&quot;/user&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure><hr><h2 id="Config-配置选项"><a href="#Config-配置选项" class="headerlink" title="Config 配置选项"></a>Config 配置选项</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//服务器地址</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// 请求方式</span></span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,<span class="comment">//默认get</span></span><br><span class="line">    <span class="comment">//如果url不是绝对地址，则加上baseURL</span></span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line"> <span class="comment">//transformRequest允许请求的数据在发送至服务器之前进行处理，只适用put/post/patch</span></span><br><span class="line"><span class="comment">//数组中最后一个函数必须返回一个字符串或ArrayBuffer/Stream/Buffer/ArrayBuffer/Formdata</span></span><br><span class="line">    <span class="comment">//如果函数中用到了headers，则需要设置headers属性</span></span><br><span class="line">    <span class="attr">transformRequest</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//对数据进行处理</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">                &#125;],</span><br><span class="line">    <span class="comment">//transformResponse允许对返回的数据传入then/catch之前进行处理</span></span><br><span class="line">    <span class="attr">transformResponse</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">         <span class="comment">//对数据进行处理</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">                 &#125;],</span><br><span class="line">    <span class="comment">//headers自定义要被发送的消息头</span></span><br><span class="line">    <span class="attr">headers</span>: &#123; <span class="string">&#x27;x-header&#x27;</span>: <span class="string">&#x27;sds&#x27;</span> &#125;,</span><br><span class="line">    <span class="comment">//请求参数,会追加到URL后面</span></span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//用于序列化参数</span></span><br><span class="line">    <span class="attr">paramsSerializer</span>: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(params, &#123; <span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span> &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//data作为请求体的数据-- request.body</span></span><br><span class="line">    <span class="comment">//只适用于put/post/patch</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//请求时间,如果请求超过请求时间，请求将停止</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="comment">//表面跨域请求书是否需要证明</span></span><br><span class="line">    <span class="attr">withCredentials</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//适配器，允许自定义处理请求</span></span><br><span class="line">    <span class="comment">//返回一个promise</span></span><br><span class="line">    <span class="attr">adapter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">///定义服务的主机名和端口号</span></span><br><span class="line">    <span class="comment">// auth属性表示HTTP基本认证应</span></span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消请求</span></span><br><span class="line">    <span class="attr">cancelToken</span>: <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">cancel</span> =&gt;</span> &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h2><p>当发送请求或得到响应被 then 或 catch 处理之前对它们进行拦截，拦截后可以对数据做一些处理，如给数据添加头部信息或对响应信息进行序列化，然后再发送给浏览器</p><h3 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//在请求之前进行处理</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//请求错误的时候进行处理</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//对返回数据进行处理</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//响应错误进行处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>拦截器同样也可以使用在 axios 实例中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myinstance = axios.create();</span><br><span class="line">myinstance.interceptors.request.use(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="移除拦截器"><a href="#移除拦截器" class="headerlink" title="移除拦截器"></a>移除拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure><hr><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><code>validateStatus</code>设置自定义 HTTP 状态码的错误范围</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;/user&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">//当http返回状态码小于500时视为错误</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p>当用户搜索时，可能需要频繁的发送数据查询请求，因此当发送下一个请求时，需要撤销上一个请求</p><ul><li>方式一：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line">axios.get(<span class="string">&quot;/user/12345&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// An executor function receives a cancel function as a parameter</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure><ul><li>方式二：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="comment">// 通过source工厂函数创建一个cancelToken</span></span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios</span><br><span class="line">  .get(<span class="string">&quot;/user/12345&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">cancelToken</span>: source.token,</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Request canceled&quot;</span>, thrown.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">axios.post(</span><br><span class="line">  <span class="string">&quot;/user/12345&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">cancelToken</span>: source.token,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消请求</span></span><br><span class="line">source.cancel(<span class="string">&quot;用户取消请求&quot;</span>);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/axios/axios">官网文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -vue </tag>
            
            <tag> -axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue插槽</title>
      <link href="/2021/12/23/%E6%8F%92%E6%A7%BD/"/>
      <url>/2021/12/23/%E6%8F%92%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>假设我们定义了一个子组件 Category</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们在父组件中使用子组件,在子组件中插入一张图片，此时就会带来一个问题，vue 在渲染组件时会将 img 插入到 Category 的哪个位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际上，因为没有指定 img 在 Category 组件中的位置，最终渲染的结果会导致 img 无法显示</p><p>因此可以通过插槽来解决这个问题</p><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>作用：让父组件可以向子组件指定位置插入 html 结构，是组件之间通信的一种方式</p><h2 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h2><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>html结构<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--定义插槽--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>给插槽起名字，使用 name 属性</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--模板中的内容将会渲染到对应的插槽中--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>html结构<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以使用另一种写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:test2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>html结构2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--定义插槽--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span>默认插槽内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;test2&quot;</span>&gt;</span>默认插槽内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p><strong>vue 组件中父组件不能直接使用子组件的 data 数据</strong>，如果父组件需要使用子组件的 data 数据，则可以通过作用域插槽 <code>slot-scope</code></p><p>注意：</p><ul><li>作用域插槽也可以有 name 属性</li><li>slot-scope 的值是自定义的，可以取任何名称</li><li>slot-scope 就是取的子组件的 data</li></ul><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scopeData&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;myslot&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- scopeData.sourcedata为子组件中的data.sourcedata --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in scopeData.sourcedata&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二种方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123;sourcedata&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in sourcedata&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">&quot;sourcedata&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myslot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">name</span>: <span class="string">&quot;Category&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">//数据在子组件本身</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">sourcedata</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>],</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2021/12/22/%E6%A0%91/"/>
      <url>/2021/12/22/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是 n(n≥0)个结点的有限集，当 n=0 时，称为空树。</p><p>在任意非空树中满足：</p><ul><li>有且仅有一个特定的根</li><li>当 n&gt;1 时，其余结点可分为 m(m&gt;0)个互不相交的有限集 T1,T2,…,Tm,其中每个集合本身又是一颗树，并且称为根的<strong>子树</strong></li></ul><p>树的定义是递归的，即<strong>树是一种递归的数据结构</strong></p><p>树结构的特点：</p><ul><li>树的根结点没有前驱结点，除根结点以外的所有结点有且只有一个前驱结点</li><li>树中所有结点可以有 0 或多个后继结点</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>结点的度：一个结点的子树个数</li><li>树的度：树中结点的最大度数</li><li>叶结点：度为 0 的结点，也叫终结结点</li><li>非叶结点：度不为 0 的结点，也叫非终结结点</li><li>结点的深度：从根结点开始自顶向下逐层累加</li><li>结点的层次：从树根开始，根结点为第一层，它的子结点为第 2 层，以此类推</li><li>路径长度(路长)：等于路径中结点数-1</li><li>结点的高度：结点到叶结点的最大路长+1</li><li>树的高度：即根结点的高度，也是该树中所有结点中的最大层号</li><li>有序树：树中结点的各子树从左到右都是有次序的，不能互换，否则称为无序树</li><li>森林：森林是 m(m≥0)棵互不相交的树的集合，将树的根结点去掉就成为森林。</li></ul><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><ul><li><p>1.树中的结点数等于所有结点的度数和+1</p></li><li><p>2.度为 m 的树中第 i 层上至多有 ${m^{i-1}}$ 个结点</p></li><li><p>3.高度为 h 的 m 叉树至多有${(m^{h}-1)}/{(m-1)}$个结点</p></li><li><p>4.具有 n 个结点的 m 叉树的最小高度为${\lceil \log_m{(n(m-1)+1)} \rceil}$</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112221057084.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/12/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>算法思想：</p><ul><li>每次将一个待排序的记录按其关键字大小插入已排序好的子序列的适当位置，直到所有待排序记录全部插入为止。</li><li>可以假设第一个元素已经排序好，从待排序队列中取出一个元素，从后往前扫描<strong>已经排序好</strong>的元素序列，将元素插入到合适位置。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112081950596.gif"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">           <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])<span class="comment">//</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> j;</span><br><span class="line">               <span class="keyword">int</span> temp=nums[i];<span class="comment">//待排序的元素</span></span><br><span class="line">               <span class="keyword">for</span>(j=i<span class="number">-1</span>;temp&lt;nums[j];--j)</span><br><span class="line">               &#123;</span><br><span class="line">                    nums[j+<span class="number">1</span>]=nums[j];<span class="comment">//已排序好的队列元素后移</span></span><br><span class="line">               &#125;</span><br><span class="line">               nums[j+<span class="number">1</span>]=temp;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(n^2)}$</td><td>${O(n^2)}$</td><td>${O(1)}$</td><td>稳定</td></tr></tbody></table><hr><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序也叫缩小增量排序</p><p>算法思想：</p><ul><li><p>将整个待排序的序列分成若干个子序列，在子序列内分别进行直接插入排序，使得整个序列逐步向基本有序方向发展，待整个序列基本有序时，再对整体进行一次直接插入排序。</p></li><li><p><strong>步长</strong>(间距)序列的选取是希尔排序的重要部分，常用的步长有：</p><p>d=n/2 再取 d=d/2,直到 d=1</p><p>d=n/3 再取 d=d/3+1,直到 d=1</p></li><li><p>所有间距为 d 的元素视为一个子序列，在每个子序列中进行直接插入排序，再缩小步长，直到 d=1</p></li></ul><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,d;<span class="comment">//d为步长</span></span><br><span class="line">        <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>)<span class="comment">//子序列</span></span><br><span class="line">            <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//子序列内部使用直接插入排序</span></span><br><span class="line">              <span class="keyword">if</span>(nums[i]&lt;nums[i-d])<span class="comment">//后面比前面小</span></span><br><span class="line">              &#123;</span><br><span class="line">                 <span class="keyword">int</span> tmp=nums[i];<span class="comment">//待排序的元素</span></span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> j=i-d;tmp&lt;nums[j]&amp;&amp;j&gt;<span class="number">0</span>;j-=d)</span><br><span class="line">                 &#123;</span><br><span class="line">                     nums[j+d]=nums[j];</span><br><span class="line">                 &#125;</span><br><span class="line">                 nums[j+d]=tmp;</span><br><span class="line">              &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(nlog_2{n})}$</td><td>${O(n^2)}$</td><td>${O(1)}$</td><td>不稳定</td></tr></tbody></table><hr><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>算法思想:</p><p>对于 n 个待排序的元素</p><ul><li>每次比较相邻两个元素的大小，并将元素较大的往后排</li><li>每次循环后，较大的元素将会依次排列到最后</li><li>至多执行 n-1 次循环</li></ul><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112081645860.gif"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">int</span> swap=<span class="number">0</span>;<span class="comment">//交换标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n-i<span class="number">-1</span>;j++)<span class="comment">//每次循环都会有一个较大的数排到最后</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])<span class="comment">//前面的数比后面的大就交换</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">int</span> temp=nums[j];</span><br><span class="line">               nums[j]=nums[j+<span class="number">1</span>];</span><br><span class="line">               nums[j+<span class="number">1</span>]=temp;</span><br><span class="line">               swap=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果一次都没有交换，说明原数组已经排序好</span></span><br><span class="line">        <span class="keyword">if</span>(swap==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(n^2)}$</td><td>${O(n^2)}$</td><td>${O(1)}$</td><td>稳定</td></tr></tbody></table><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>算法思想：</p><ul><li>在待排序的序列中选择某个关键字作为基准元素</li><li>用基准元素将原序列进行划分，关键字小于基准元素的交换到前面，关键字大于等于基准元素的交换到后面</li><li>再对划分后的子序列进行<strong>递归</strong>快速排序，直到整个序列有序为止</li></ul><p><strong>注意</strong>：基准元素的选择是任意的，但不同的选择方法对算法的性能影响较大，常见的选取方法有：</p><ul><li>选取第一个关键字作为基准元素</li><li>选取最先找到的两个不同关键字中的较大者作为基准元素（适用于待排序序列中存在大量相同关键字的情形）</li><li>选取 nums[i].key，nums[(i+j)/2].key，nums[j].key 的中值作为基准元素（适用于均匀分布的待排序序列）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112081818127.gif"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里选取待排序序列中第一个关键字作为基准元素</span></span><br><span class="line"><span class="comment">//low指针指向关键字大于等于基准元素的位置</span></span><br><span class="line"><span class="comment">//heigh指针指向关键字小于基准元素的位置</span></span><br><span class="line"><span class="comment">//找到后进行交换，保证左侧是小于基准元素的序列，右侧是大于等于基准元素的序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>&amp; nums[],<span class="keyword">int</span> low,<span class="keyword">int</span> heigh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(low&gt;=heigh)<span class="comment">//递归终止</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> left=low;</span><br><span class="line">       <span class="keyword">int</span> right=heigh;</span><br><span class="line">       <span class="keyword">int</span> key=nums[left];<span class="comment">//第一个为基准元素</span></span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//将比基准元素小的移到前面</span></span><br><span class="line">          <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]&gt;=key)</span><br><span class="line">                 right--;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将比基准元素大的移到后面</span></span><br><span class="line">           <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]&lt;key)</span><br><span class="line">              left++;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[right]=nums[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       nums[left]=key;</span><br><span class="line">       <span class="comment">//左部分递归快速排序</span></span><br><span class="line">       <span class="built_in">QuickSort</span>(nums,low,left<span class="number">-1</span>);</span><br><span class="line">       <span class="comment">//右部分递归快速排序</span></span><br><span class="line">       <span class="built_in">QuickSort</span>(nums,left+<span class="number">1</span>,heigh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>平均空间复杂度</th><th>最坏空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(n\log_2{n})}$</td><td>${O(n^2)}$</td><td>${O(\log_2{n})}$</td><td>${O(n)}$</td><td>不稳定</td></tr></tbody></table><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><p>算法思想：</p><ul><li>第一遍从待排序序列中选出一个关键字最小的元素，和第一个元素进行交换</li><li>第二遍从剩余未排序序列中选出一个关键字最小的元素，和第二个元素进行交换</li><li>以此类推，直到排序完成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112092005346.gif"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowindex;<span class="comment">//关键字最小的元素</span></span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lowindex=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[lowindex])</span><br><span class="line">            &#123;</span><br><span class="line">                lowindex=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//将最小的元素放到前面</span></span><br><span class="line">        tmp=nums[i];</span><br><span class="line">        nums[i]=nums[lowindex];</span><br><span class="line">        nums[lowindex]=tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(n^2)}$</td><td>${O(n^2)}$</td><td>${O(1)}$</td><td>数组不稳定，链表稳定</td></tr></tbody></table><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>算法思想：</p><ul><li><p>利用堆数据结构实现排序，将待排序的元素数组看成是一颗完全二叉树的顺序表示</p></li><li><p>堆的性质：父结点的关键字大小总是大于等于（或小于等于）子结点的关键字</p></li><li><p>将初始待排序序列 A[n]构建成最大堆，则 A[1]为待排序序列中关键字最大的元素</p></li><li><p>将堆的根 A[1]与 A[n]交换，此时得到新的无序序列{ A[1]，A[2],… ,A[n-1] }和新的有序序列{A[n]}</p></li><li><p>由于交换后的堆顶元素 A[1]可能不符合堆的性质，所以需要对当前的无序序列重新整理成新堆，新堆的根 A[1]为第二个关键字最大的元素</p></li><li><p>重复以上操作，直到有序序列的元素个数为 n-1</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112111940214.gif"></p></li></ul><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//构建最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="comment">//建立父节点指标和子节点指标</span></span><br><span class="line"> <span class="keyword">int</span> dad = start;</span><br><span class="line"> <span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">//若子节点在范围内才做比较</span></span><br><span class="line"><span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">//先比较两个子节点指标，选择最大的</span></span><br><span class="line">son++;</span><br><span class="line"><span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完成，直接跳出函数</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//否则交换父子內容再继续子节点与孙节点比較</span></span><br><span class="line"><span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">dad = son;</span><br><span class="line">son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//堆排序</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父节点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完成</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line"><span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(n{log_2{n}})}$</td><td>${O(n{log_2{n}})}$</td><td>${O(1)}$</td><td>不稳定</td></tr></tbody></table><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>算法思想：</p><ul><li><p>归并：将两个或两个以上已排序好的序列合并成一个新的排序序列，将两个已排序好的子序列合并成一个新的排序序列称为二路归并排序。</p></li><li><p>将待排序的序列划分为左右长度大致相等的两个子序列 { A[left],…,A[mid] } 和 { A[mid+1],…,A[right] }，划分点 mid=(left+right)/2</p></li><li><p>然后对两个子序列递归地进行归并排序</p></li><li><p>最后将左右两个已经排序好的子序列归并为一个有序序列</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112111939854.gif"></p><p>代码实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个有序序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"><span class="comment">//表A[low...mid],A[mid+1...high]各自有序，将其合并为有序表B[low...high]</span></span><br><span class="line"><span class="keyword">int</span> i=low,j=mid+<span class="number">1</span>,k=high;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;A[j])</span><br><span class="line">B[k++]=A[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">B[k++]=A[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)   B[k++]=A[i++];         <span class="comment">//若第一个表没检测完，直接复制</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;=high)   B[k++]=A[j++];         <span class="comment">//第二个....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)</span><br><span class="line">A[k]=B[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low==high)</span><br><span class="line">      B[high]=A[high];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;          <span class="comment">//从中间划分两个子序列</span></span><br><span class="line"><span class="built_in">MergeSort</span>(A,B,low,mid);          <span class="comment">//从左侧子序列进行递归排序</span></span><br><span class="line"><span class="built_in">MergeSort</span>(A,B,mid+<span class="number">1</span>,high);       <span class="comment">//从右侧子序列进行递归排序</span></span><br><span class="line"><span class="built_in">Merge</span>(A,B,low,mid,high);       <span class="comment">//将两个有序表合成一个有序表</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(n{log_2{n}})}$</td><td>${O(n{log_2{n}})}$</td><td>${O(n)}$</td><td>稳定</td></tr></tbody></table><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序是一个基于非比较的排序算法，其核心在于将输入的数据值进行统计并存储在额外开辟的数组空间中。</p><p>例如待排序数组中元素 i 出现了 n 次，则存储在额外的数组 Count[i]=n</p><p>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。<br>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</p><p>算法思想：</p><ul><li><p>找出待排序数组中最大 max 和最小的元素 min</p></li><li><p>开辟一个长度为 max-min+1 的数组空间 Count (防止空间过度浪费)</p></li><li><p>统计数组中元素 i 的出现次数，并存入数组 Count[i-min]</p></li><li><p>对所有的计数累加（从 Count 中的第一个元素开始，后一项加上前一项并存入后一项）</p></li><li><p>反向填充目标数组：将原数组每个元素 i 放在新数组 target 的第 Count[i]项，每放一个元素就将 Count[i]减去 1</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112111846432.gif"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> min,max;</span><br><span class="line">      min=max=nums[<span class="number">0</span>];<span class="comment">//假设初始最小和最大都是第一个数</span></span><br><span class="line">      <span class="comment">//找到最小和最大的数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[i]&lt;min)</span><br><span class="line">            min=nums[i];</span><br><span class="line">          <span class="keyword">if</span>(nums[i]&gt;max)</span><br><span class="line">           max=nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//计数数组</span></span><br><span class="line">      <span class="keyword">int</span> count[max-min+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始为0</span></span><br><span class="line">      <span class="keyword">int</span> len=max-min+<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//统计</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">           count[nums[i]-min]++;</span><br><span class="line">      <span class="comment">//累加</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">           count[i]+=count[i<span class="number">-1</span>];</span><br><span class="line">       <span class="comment">//反向填充目标数组</span></span><br><span class="line">       vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">target</span>(n,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">           target[--count[nums[i]-min]]=nums[i];</span><br><span class="line">       <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(n+k)}$</td><td>${O(n+k)}$</td><td>${O(n+k)}$</td><td>稳定</td></tr></tbody></table><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>相比于以上几种排序算法，都是把关键字作为一个整体，通过比较关键字的大小调整序列的位置，而基数排序不比较关键字的大小而是<strong>考虑构成关键字的每个分量</strong>，根据分量的值排列序列的顺序。</p><p>算法思想：</p><ul><li><p>找到待排序序列中最大的数并取得位数，假设最大的位数为 figure</p></li><li><p>待排序序列的关键字可以看成含有 figure 个分量，每个分量的值可为 0,1,2,…,9，即其基数为 10。从最低位开始依次考察每个分量。</p></li><li><p>首先将待排序的关键字序列全部装入一个队列 A</p></li><li><ol><li>初态：设置 10 个队列，分别为 Q[0],Q[1],…,Q[9],使其均为空</li></ol></li><li><ol start="2"><li>分配：从队列 A 中取出每个关键字，第 p 遍处理时(1=&lt;p&lt;=figure)时，考察关键字右边第 p 个分量(右边第 p 位数)，并将其插入对应的队列。(假设右边第 p 个分量的值为 r，则将其插入到队列 Q[r]中。)</li></ol></li><li><ol start="3"><li>收集：从 Q[0]开始依次取出 Q[0],Q[1],Q[2],…,Q[9]中的全部数据，并且按照取出的顺序，将每个数据插入到队列 A 中</li></ol></li><li><ol start="4"><li>循环：重复以上 1、2、3 的步骤，对关键字中有 figure 位的数据，执行 figure 遍。</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202112111936949.gif"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求关键字key第p位数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Radix</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> power = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p - <span class="number">1</span>; i++)</span><br><span class="line">        power = power * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ((key % (power * <span class="number">10</span>)) / power);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> figure, queue&lt;<span class="keyword">int</span>&gt;&amp; A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= figure; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">while</span> (!Q[i].<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                Q[i].<span class="built_in">pop</span>();</span><br><span class="line">            &#125;;<span class="comment">//清空队列Q[i]</span></span><br><span class="line">        <span class="comment">//分配</span></span><br><span class="line">        <span class="keyword">while</span> (!A.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            key = A.<span class="built_in">front</span>();</span><br><span class="line">            A.<span class="built_in">pop</span>();</span><br><span class="line">            r = <span class="built_in">Radix</span>(key, p);</span><br><span class="line">            Q[r].<span class="built_in">push</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//收集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">while</span> (!Q[i].<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                key = Q[i].<span class="built_in">front</span>();</span><br><span class="line">                Q[i].<span class="built_in">pop</span>();</span><br><span class="line">                A.<span class="built_in">push</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>平均时间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td>${O(k*n)}$</td><td>稳定</td></tr></tbody></table><p><strong>注意：</strong>(k 表示关键字的位数)</p><hr><p>算法动图演示来源 <a href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2021/11/11/vuex/"/>
      <url>/2021/11/11/vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="vuex-概述"><a href="#vuex-概述" class="headerlink" title="vuex 概述"></a>vuex 概述</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>即<br><strong>vuex 把组件的共享状态抽取出来，以一个全局单例模式管理。</strong></p><hr><h3 id="vuex-使用场景"><a href="#vuex-使用场景" class="headerlink" title="vuex 使用场景"></a>vuex 使用场景</h3><ul><li>多个组件依赖于同一状态。</li><li>来自不同组件的行为需要变更同一状态</li></ul><hr><h3 id="状态管理模式示意图"><a href="#状态管理模式示意图" class="headerlink" title="状态管理模式示意图"></a>状态管理模式示意图</h3><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202111050846988.png"></p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm 方式安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><p><a href="https://vuex.vuejs.org/zh/installation.html">其他安装方式</a></p><hr><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Vuex 使用单一状态树,用一个对象就包含了全部的应用层级状态,<strong>每个应用将仅仅包含一个 store 实例</strong>，单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照，存储在 Vuex 中的数据和 Vue 实例中的 data 遵循相同的规则</p><h4 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h4><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&quot;count&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    <span class="function"><span class="title">countPlusLocalState</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&quot;count&quot;</span>,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h4 id="对象展开"><a href="#对象展开" class="headerlink" title="对象展开"></a>对象展开</h4><p>mapState 函数返回的是一个对象。通过<strong>对象展开</strong>将它与局部计算属性混合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数,如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，<strong>getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</strong>。</p><p>getters 接受 state 作为其第一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">todos</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&quot;...&quot;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&quot;...&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function">(<span class="params">todo</span>) =&gt;</span> todo.done);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在组件中使用它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h4><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&quot;doneTodosCount&quot;</span>,</span><br><span class="line">      <span class="string">&quot;anotherGetter&quot;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><strong>不能直接调用一个 mutation handler</strong>。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">&quot;increment&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h4><p>可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 载荷（payload）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">&quot;increment&quot;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">&quot;increment&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h4><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，我们无法确定哪个先回调。在 Vuex 中，mutation 都是<strong>同步事务</strong>。<br>异步处理可通过 actions。</p><hr><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意<strong>异步</strong>操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">   <span class="function"><span class="title">increment</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">     context.commit(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Action 函数接受一个<strong>与 store 实例具有相同方法和属性的 context 对象</strong>，因此可以调用<code>context.commit</code>提交一个 mutation，或者通过<code> context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters</p><h4 id="分发-Action，执行异步操作"><a href="#分发-Action，执行异步操作" class="headerlink" title="分发 Action，执行异步操作"></a>分发 Action，执行异步操作</h4><p>mutation 必须同步执行,而在 action 内部可执行异步操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Actions-支持同样的载荷方式和对象方式进行分发"><a href="#Actions-支持同样的载荷方式和对象方式进行分发" class="headerlink" title="Actions 支持同样的载荷方式和对象方式进行分发"></a>Actions 支持同样的载荷方式和对象方式进行分发</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">&quot;incrementAsync&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;incrementAsync&quot;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h4 id="组件分发-Action"><a href="#组件分发-Action" class="headerlink" title="组件分发 Action"></a>组件分发 Action</h4><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;) </code>分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 store）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">&quot;increment&quot;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">&quot;incrementBy&quot;</span>, <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&quot;increment&quot;</span>, <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h4><p><a href="https://vuex.vuejs.org/zh/guide/actions.html#%E7%BB%84%E5%90%88-action">见官方说明</a></p><hr><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。<strong>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</strong>——从上至下进行同样方式的分割</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><hr><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象 state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">doubleCount</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">incrementIfOddOnRootSum</span>(<span class="params">&#123; state, commit, rootState &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">&quot;increment&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">sumWithRootCount</span>(<span class="params">state, getters, rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><a href="https://vuex.vuejs.org/zh/guide/modules.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">更多 Modules 相关内容</a></p><hr><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>每一个 Vuex 应用的<strong>核心</strong>就是 <strong>store（仓库）</strong>。“store”基本上就是一个容器，它包含着应用中大部分的状态 (state)。</p><p>Vuex 和单纯的全局对象有以下两点不同：</p><ul><li><p><strong>Vuex 的状态存储是响应式的</strong>。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p></li><li><p><strong>不能直接改变 store 中的状态</strong> 改变 store 中的状态的 <strong>唯一途径就是显式地提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化。</p></li></ul><hr><h3 id="一个简单的-store"><a href="#一个简单的-store" class="headerlink" title="一个简单的 store"></a>一个简单的 store</h3><p>注意这是一个单独的文件，在 src 目录下新建 store 目录，新建 index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">//引入vuex</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="comment">//注意在引入store之前要使用vuex</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>为了在 Vue 组件中访问 <code>this.$store.property</code>，需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 store 选项的方式“注入”该 store 的机制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">  <span class="attr">store</span>: store,</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="在组件方法中提交变更"><a href="#在组件方法中提交变更" class="headerlink" title="在组件方法中提交变更"></a>在组件方法中提交变更</h4><p>可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code>提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="分发-action"><a href="#分发-action" class="headerlink" title="分发 action"></a>分发 action</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;add&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再通过 store 中的 actions 提交 mutation</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">       context.commit(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutations 处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://vuex.vuejs.org/zh/">更多内容详见官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -vue </tag>
            
            <tag> -vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建一个简单的spring项目</title>
      <link href="/2021/11/10/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84spring%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/11/10/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84spring%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring 作为容器管理对象，开发人员可以从 Spring 中获取要使用的对象</strong></p><h2 id="step1-创建一个空项目"><a href="#step1-创建一个空项目" class="headerlink" title="step1:创建一个空项目"></a>step1:创建一个空项目</h2><p>在空项目新建一个 Module, File-&gt;new-&gt;module，选择 maven<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202111102021996.png"></p><hr><h2 id="step2-添加依赖"><a href="#step2-添加依赖" class="headerlink" title="step2: 添加依赖"></a>step2: 添加依赖</h2><p>修改 pom.xml,maven 项目创建时会引入一些插件和依赖，这里为简便只加入了部分依赖，修改完毕后，导入依赖即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    spring依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    单元测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="step3-定义接口和实现类"><a href="#step3-定义接口和实现类" class="headerlink" title="step3:定义接口和实现类"></a>step3:定义接口和实现类</h2><p>在 service 包下定义一个 someservice 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">someservice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.service.Impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.service.someservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">someserviceImpl</span> <span class="keyword">implements</span> <span class="title">someservice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dosome()方法被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="step4-创建-spring-的配置文件"><a href="#step4-创建-spring-的配置文件" class="headerlink" title="step4:创建 spring 的配置文件"></a>step4:创建 spring 的配置文件</h2><p>用来<strong>声明对象</strong>，把对象交给 spring 容器创建和管理。<br>在 main 目录下，建立 resources 资源文件夹，在文件夹下新建一个 springCofig 文件 Beans.xml</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202111102033621.png"></p><p>spring 配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      声明Java对象--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    id:自定义对象名称，唯一值</span></span><br><span class="line"><span class="comment">        class:类的全限定名称，spring通过反射机制创建对象，不能是接口(接口不能实例化对象)</span></span><br><span class="line"><span class="comment">        spring 根据Id，class创建对象，把对象放入到spring的一个map对象</span></span><br><span class="line"><span class="comment">        map.put(id,对象)--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--使用&lt;bean&gt;表示对象声明，一个bean表示一个Java对象--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--bean就是spring容器管理的Java对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;someservice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.service.Impl.someserviceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="step5-创建spring容器对象ApplicationContext"><a href="#step5-创建spring容器对象ApplicationContext" class="headerlink" title="step5:创建spring容器对象ApplicationContext"></a>step5:创建spring容器对象ApplicationContext</h2><p>获取容器中的对象，使用<code>getBean(&quot;对象名称&quot;)</code>(有重载形式)</p><p><strong>注意</strong>：</p><ul><li>spring 容器创建对象，默认调用类的无参数的构造函数</li><li>Spring 创建容器对象ApplicationContext时，默认会同时创建配置文件中声明的所有对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> org.example.service.someservice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.指定spring的配置文件,从类路径(classpath)(即target下的classes路径)之下开始的路径</span></span><br><span class="line">        String config=<span class="string">&quot;Beans.xml&quot;</span>;</span><br><span class="line">        <span class="comment">//2.创建容器对象,applicationContext为接口，classpathxmlapplicationContext为接口的实现类,从类路径下读取配置文件，创建文件中声明的Java对象</span></span><br><span class="line">        ApplicationContext applicationContext=<span class="keyword">new</span> ClassPathXmlApplicationContext(config);</span><br><span class="line">        <span class="comment">//3.从容器中获取指定的对象 getBean(&quot;id&quot;)</span></span><br><span class="line">         someservice service=(someservice) applicationContext.getBean(<span class="string">&quot;someservice&quot;</span>);</span><br><span class="line">         <span class="comment">//getBean()方法有多种重载形式</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *someservice service = applicationContext.getBean(org.example.service.someservice.class);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//4.调用对象中的方法</span></span><br><span class="line">        service.dosome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，运行 main 函数<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202111102042475.png"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
            <tag> -Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC与三层架构</title>
      <link href="/2021/11/03/MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/11/03/MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h2><p>MVC(Model-View-Controller)是软件工程中的一种软件架构设计模式，它把软件系统分为<strong>模型、视图、控制器</strong>三部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，广泛应用于 Web 和桌面应用程序。</p><hr><h2 id="MVC-每层之间的逻辑关系"><a href="#MVC-每层之间的逻辑关系" class="headerlink" title="MVC 每层之间的逻辑关系"></a>MVC 每层之间的逻辑关系</h2><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202111031752576.png"></p><h3 id="M：Model-模型"><a href="#M：Model-模型" class="headerlink" title="M：Model(模型)"></a>M：Model(模型)</h3><ul><li><p>完成具体的业务操作：如对数据库操作、封装数据对象</p></li><li><p>Model 可以是一个 JavaBean，也可以是一个包含多个对象的 Map</p></li></ul><h3 id="V：View-视图"><a href="#V：View-视图" class="headerlink" title="V：View(视图)"></a>V：View(视图)</h3><ul><li>前端页面(jsp、html…)展示数据</li></ul><h3 id="C：Controller-控制器"><a href="#C：Controller-控制器" class="headerlink" title="C：Controller(控制器)"></a>C：Controller(控制器)</h3><ul><li><p>专注于业务处理，处理结果为 Model</p></li><li><p>获取 View 请求</p></li><li><p>调用 Model 将数据响应给 View 进行数据展示</p></li><li><p>在 Web 开发中 Servlet 实现控制器</p></li></ul><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>三层架构是一种软件架构，分为：<strong>表现层</strong>、<strong>业务逻辑层</strong>、<strong>数据访问层</strong>再加上<strong>实体类库(Model)</strong></p><ul><li>数据访问层：对数据库相关的操作</li><li>业务逻辑层：处理涉及业务逻辑相关的问题,将表现层和数据访问层联系起来，例如：在访问数据库之前，预处理数据</li><li>实体类库：用专门的类抽象出数据表的结构，类的属性一一对应表的属性</li></ul><h2 id="MVC-与三层架构关系"><a href="#MVC-与三层架构关系" class="headerlink" title="MVC 与三层架构关系"></a>MVC 与三层架构关系</h2><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202111031818242.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet相关知识</title>
      <link href="/2021/10/28/Servlet/"/>
      <url>/2021/10/28/Servlet/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Servlet（Server Applet）是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，将 Servlet 理解为后者。<br>Servlet 运行于支持 Java 的应用服务器中。从实现上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。</p><hr><h2 id="在-web-xml-配置-servlet-程序"><a href="#在-web-xml-配置-servlet-程序" class="headerlink" title="在 web.xml 配置 servlet 程序"></a>在 web.xml 配置 servlet 程序</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;servlet&gt;标签给Tomcat配置servlet程序--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        servlet-name标签给servlet程序起一个别名(一般是类名)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        全类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.test<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    servlet-mapping 标签给servlet程序配置访问地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        servlet-name标签告诉服务器，当前配置的地址给哪个servlet程序使用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--       &lt;url-pattern&gt; 标签配置访问地址</span></span><br><span class="line"><span class="comment">       / 斜杠在服务器解析的时候，表示地址为http://ip:port/工程路径</span></span><br><span class="line"><span class="comment">       /test 表示地址为http://ip:port/工程路径/test--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置路径要以斜杠/开头，否则会容易出错--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过注解的方式配置 Servlet 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;test&quot;, value = &quot;/test&quot;)</span></span><br></pre></td></tr></table></figure><hr><h2 id="servlet-接口定义的方法"><a href="#servlet-接口定义的方法" class="headerlink" title="servlet 接口定义的方法"></a>servlet 接口定义的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    ServletConfig是servlet程序的配置信息类</span></span><br><span class="line">   <span class="comment">//    Servlet程序和ServletConfig对象都是由Tomcat负责创建</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// service方法专门用来处理请求和响应</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="servlet-生命周期方法"><a href="#servlet-生命周期方法" class="headerlink" title="servlet 生命周期方法"></a>servlet 生命周期方法</h2><p>init( ),service( ),destroy( )是 Servlet 生命周期的方法。代表了 Servlet 从“出生”到“工作”再到“死亡 ”的过程。Servlet 容器（例如 TomCat）会根据下面的规则来调用这三个方法：</p><hr><h3 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h3><p>1.init( ),当 Servlet 第一次被请求时，Servlet 容器就会开始调用这个方法来初始化一个 Servlet 对象，但是这个方法在后续请求中不会在被 Servlet 容器调用，就像人只能“出生”一次一样。我们可以利用 init（）方法来执行相应的初始化工作。调用这个方法时，Servlet 容器会传入一个 ServletConfig 对象进来从而对 Servlet 对象进行初始化。</p><hr><h3 id="service"><a href="#service" class="headerlink" title="service()"></a>service()</h3><p>2.service( )方法，每当请求 Servlet 时，Servlet 容器就会调用这个方法。第一次请求时，Servlet 容器会先调用 init( )方法初始化一个 Servlet 对象出来，然后会调用它的 service( )方法进行工作，但在后续的请求中，Servlet 容器只会调用 service 方法。</p><h4 id="在-service-方法中获取请求方式"><a href="#在-service-方法中获取请求方式" class="headerlink" title="在 service 方法中获取请求方式"></a>在 service 方法中获取请求方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">  <span class="comment">//类型转换,ServletRequest没有getMethod()方法，它的子类HttpServletRequest有</span></span><br><span class="line">    HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest;</span><br><span class="line"> <span class="comment">//获取请求的方式</span></span><br><span class="line">    String method=httpServletRequest.getMethod();</span><br><span class="line">    System.out.print(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy()"></a>destroy()</h3><p>3.destroy,当要销毁 Servlet 时，Servlet 容器就会调用这个方法，</p><hr><h2 id="ServletConfig-对象"><a href="#ServletConfig-对象" class="headerlink" title="ServletConfig 对象"></a>ServletConfig 对象</h2><h3 id="web-xml-配置-servlet-程序初始化参数"><a href="#web-xml-配置-servlet-程序初始化参数" class="headerlink" title="web.xml 配置 servlet 程序初始化参数"></a>web.xml 配置 servlet 程序初始化参数</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.test<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;init-param&gt;是初始化参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            参数名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            参数值--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过-ServletConfig-对象获取-servlet-程序的配置信息"><a href="#通过-ServletConfig-对象获取-servlet-程序的配置信息" class="headerlink" title="通过 ServletConfig 对象获取 servlet 程序的配置信息"></a>通过 ServletConfig 对象获取 servlet 程序的配置信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">//        1.可以获取servlet程序的别名(servlet-name)</span></span><br><span class="line">        System.out.print(servletConfig.getServletName());</span><br><span class="line"><span class="comment">//        2.获取servlet程序的初始化参数</span></span><br><span class="line">        System.out.print(servletConfig.getInitParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line"><span class="comment">//      3.获取servletContext对象</span></span><br><span class="line">        System.out.print(servletConfig.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="ServletContext-类"><a href="#ServletContext-类" class="headerlink" title="ServletContext 类"></a>ServletContext 类</h2><p>ServletContext 表示 Servlet 上下文对象<br>一个 Web 工程只有一个 ServletContext 对象实例<br>ServletContext 对象是一个域对象，可以存取数据</p><h3 id="获取-web-xml-中配置的上下文参数-context-param"><a href="#获取-web-xml-中配置的上下文参数-context-param" class="headerlink" title="获取 web.xml 中配置的上下文参数 context-param"></a>获取 web.xml 中配置的上下文参数 context-param</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--context-param是上下文参数，属于整个web工程--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>test<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取servletcontext对象</span></span><br><span class="line"><span class="comment">//方法一:通过servletConfig对象获取servletContext对象</span></span><br><span class="line"> ServletConfig servletConfig=getServletConfig();</span><br><span class="line"> ServletContext servletContext=servletConfig.getServletContext();</span><br><span class="line"><span class="comment">// 方法二:</span></span><br><span class="line"> ServletContext servletContext=getServletContext();</span><br><span class="line"> <span class="comment">//  获取上下文参数</span></span><br><span class="line"> String test= servletContext.getInitParameter(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="获取当前的工程路径"><a href="#获取当前的工程路径" class="headerlink" title="获取当前的工程路径"></a>获取当前的工程路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servletContext.getContextPath();</span><br></pre></td></tr></table></figure><hr><h3 id="获取工程部署后在服务器硬盘上的绝对路径"><a href="#获取工程部署后在服务器硬盘上的绝对路径" class="headerlink" title="获取工程部署后在服务器硬盘上的绝对路径"></a>获取工程部署后在服务器硬盘上的绝对路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斜杠在服务器解析的时候，表示地址为http://ip:port/工程路径（web目录）</span></span><br><span class="line">servletContext.getRealPath(<span class="string">&quot;/&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="像-Map-一样存取数据"><a href="#像-Map-一样存取数据" class="headerlink" title="像 Map 一样存取数据"></a>像 Map 一样存取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">servletContext.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">System.out.println(servletContext.getAttribute(<span class="string">&quot;key1&quot;</span>));</span><br></pre></td></tr></table></figure><hr><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="请求的-HTTP-协议格式"><a href="#请求的-HTTP-协议格式" class="headerlink" title="请求的 HTTP 协议格式"></a>请求的 HTTP 协议格式</h3><p>请求体: 发送给服务器的数据</p><h4 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h4><ul><li>请求行<ul><li>请求的方式 get</li><li>请求的资源路径[+?+请求参数]</li><li>请求的协议版本号 HTTP/1.1</li></ul></li><li>请求头<ul><li>key:value 组成不同的键值对,不同的键值对有不同的意义</li></ul></li></ul><hr><h4 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h4><p>同上</p><hr><h4 id="常用的请求头"><a href="#常用的请求头" class="headerlink" title="常用的请求头"></a>常用的请求头</h4><p>Accept:客户端可以接收的数据类型</p><p>Accept-Language:客户端可以接收的语言类型</p><p>User-Agent:客户端浏览器的信息</p><p>Host:表示请求时服务器 IP 和端口号</p><p>….</p><hr><h4 id="GET-请求有哪些"><a href="#GET-请求有哪些" class="headerlink" title="GET 请求有哪些"></a>GET 请求有哪些</h4><ul><li>1.form 标签 method=get</li><li>2.a 标签</li><li>3.link 标签引入 css</li><li>4.script 标签引入 js</li><li>5.img 标签引入图片</li><li>6.iframe 引入 html 页面</li><li>浏览器地址栏输入地址</li></ul><h4 id="POST-请求有哪些"><a href="#POST-请求有哪些" class="headerlink" title="POST 请求有哪些"></a>POST 请求有哪些</h4><ul><li>form 标签 method=post</li></ul><h3 id="响应的-HTTP-协议格式"><a href="#响应的-HTTP-协议格式" class="headerlink" title="响应的 HTTP 协议格式"></a>响应的 HTTP 协议格式</h3><h4 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h4><ul><li>响应的协议和版本号</li><li>响应状态码</li><li>响应状态描述</li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>类似请求头</p><h4 id="响应体-回传给客户端的数据"><a href="#响应体-回传给客户端的数据" class="headerlink" title="响应体(回传给客户端的数据)"></a>响应体(回传给客户端的数据)</h4><h4 id="常见的响应码"><a href="#常见的响应码" class="headerlink" title="常见的响应码"></a>常见的响应码</h4><ul><li><p>200 表示响应请求成功</p></li><li><p>404 表示请求服务器已经收到，但是请求的数据不存在(请求地址错误)</p></li><li><p>302 表示请求重新定向</p></li><li><p>500 表示服务器已经收到请求，但是服务器内部出错</p></li></ul><hr><!-- ### MIME 类型说明 --><hr><h2 id="HttpServletRequest-类"><a href="#HttpServletRequest-类" class="headerlink" title="HttpServletRequest 类"></a>HttpServletRequest 类</h2><p>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析封装到 Request 对象中，然后传递到 service()方法中(doGet,doPost)，之后我们可以通过 HttpServletRequest 对象，获取到所有请求的信息。</p><h3 id="HttpServletRequest-类常用方法"><a href="#HttpServletRequest-类常用方法" class="headerlink" title="HttpServletRequest 类常用方法"></a>HttpServletRequest 类常用方法</h3><ul><li>getRequestURI()</li><li>getRequestURL()</li><li>getRemoteHost() 获取客户端的 ip 地址</li><li>getHeader(“”) 获取请求头的相关信息</li><li>getQueryString()  get提交 url地址后的参数字符串</li></ul><h3 id="如何获取请求参数"><a href="#如何获取请求参数" class="headerlink" title="如何获取请求参数"></a>如何获取请求参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getParameter(<span class="string">&quot;&quot;</span>);<span class="comment">//返回请求参数的值</span></span><br></pre></td></tr></table></figure><hr><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>采用请求转发 request 对象始终存在，不会重新创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher requestDispatcher=request.getRequestDispatcher(<span class="string">&quot;/servlet2&quot;</span>);</span><br><span class="line"><span class="comment">//forward在服务器端运行，forward要在response达到客户端之前调用，否则会发生异常</span></span><br><span class="line">requestDispatcher.forward(request,response);</span><br></pre></td></tr></table></figure><hr><h3 id="request-中文乱码问题"><a href="#request-中文乱码问题" class="headerlink" title="request 中文乱码问题"></a>request 中文乱码问题</h3><p>在service中使用的编码解码方式默认为：ISO-8859-1编码，此解码不支持中文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//解决post提交方式的乱码：</span></span><br><span class="line">     request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">  <span class="comment">//解决get提交方式的乱码：</span></span><br><span class="line">   String para=req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">   <span class="keyword">new</span> String(para.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> <span class="comment">// getBytes(charset)</span></span><br><span class="line"> <span class="comment">//是java字符串处理的一个标准函数，其作用是将字符串所表示的字符按照charset进行编码，并以字节方式表示。</span></span><br><span class="line"> <span class="comment">//new String(charset)</span></span><br><span class="line"><span class="comment">//这是java字符串处理的一个标准函数，其作用是将字节数组按照charset编码进行组合识别，最后转换为unicode存储</span></span><br></pre></td></tr></table></figure><hr><h3 id="base-标签"><a href="#base-标签" class="headerlink" title="base 标签"></a>base 标签</h3><p>当页面中所有相对路径工作时，设置当前页面参照哪个路径来跳转</p><hr><h2 id="HttpServletResponse-类"><a href="#HttpServletResponse-类" class="headerlink" title="HttpServletResponse 类"></a>HttpServletResponse 类</h2><h3 id="两个输出流"><a href="#两个输出流" class="headerlink" title="两个输出流"></a>两个输出流</h3><ul><li><p>字节流</p><p>getOutputStream()</p></li><li><p>字符流</p><p>getWriter()</p></li></ul><p><strong>注意：两个只能用一个</strong></p><hr><h3 id="给客户端回传字符串数据"><a href="#给客户端回传字符串数据" class="headerlink" title="给客户端回传字符串数据"></a>给客户端回传字符串数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> PrintWriter writer=response.getWriter();</span><br><span class="line"><span class="comment">//         writer.print(&quot;&quot;);</span></span><br><span class="line"> writer.write(<span class="string">&quot;response content&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="response-中文乱码问题"><a href="#response-中文乱码问题" class="headerlink" title="response 中文乱码问题"></a>response 中文乱码问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//       方法一</span></span><br><span class="line">       response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//       通过设置响应头，设置浏览器也使用UTF-8字符集</span></span><br><span class="line">       response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html;charaset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//       方法二,会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头</span></span><br><span class="line"><span class="comment">//此方法一定要在获取流对象之前调用才有效</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charaset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p>请求重定向的特点：</p><ul><li>1.浏览器地址栏会发生变化</li><li>2.两次请求</li><li>3.不共享 request 域中的数据，会产生一个新的 request</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        第一种请求重定向方法</span></span><br><span class="line"><span class="comment">//        设置响应状态码302，表示重定向</span></span><br><span class="line">        response.setStatus(<span class="number">302</span>);</span><br><span class="line"><span class="comment">//      url表示重定向的新地址,要以/开头</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="comment">// 请求重定向的第二种方法</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;url&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
            <tag> -Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet+tomcat+数据库搭建Web应用</title>
      <link href="/2021/10/20/servlet%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2021/10/20/servlet%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>Tomcat(9.0.52)+mysql(8.0.21)+JDBC-mysql 驱动(8.0.25)+IDEA+JDK</strong></p><p><a href="http://cdn.mysql.com//Downloads/Connector-J/mysql-connector-java-8.0.25.zip">JDBC 驱动下载地址</a></p><hr><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110202050417.png"></p><p>前端登录界面的数据经过后端的处理会被存储到数据库中,后端通过操作数据库可以实现相应的功能如对数据库的增删改查等等，这里只介绍一下 Web 应用构建的大概步骤，具体实现由个人完善。</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110202110614.png"></p><hr><h2 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h2><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110202117171.png"></p><hr><h2 id="连接本地数据库"><a href="#连接本地数据库" class="headerlink" title="连接本地数据库"></a>连接本地数据库</h2><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p>下载上面的 JDBC 驱动，并解压到项目的 lib 文件夹下面，解压完毕之后，配置项目的结构，在 Modules-&gt; Dependencies 里面点击+导入刚才解压到 lib 文件夹下面的 jdbc 驱动 jar 包，因为用到 Tomcat，所以这里也需要导入本地 Tomcat 目录 lib 文件下的<strong>servlet-api 包</strong>，同时设置它们的 Scope 为 compile，防止之后的项目构建出现问题。<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110202123362.png"></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>我们先测试一下 IDEA 连接本地数据库是否成功<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110202137643.png"></p><p>然后选择 MySQL 数据库，出现下面的配置,输入自己的数据库的账号和密码，点击 Test Connection 进行测试</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110202139091.png"></p><hr><p>接下来我们使用代码连接数据库，<br>在 database 包下面新建一个类 Connect，这个类是用来连接本地数据库的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL=<span class="string">&quot;jdbc:mysql://localhost:3306/person_info&quot;</span>;<span class="comment">//数据库地址，其中person_info为数据库名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME=<span class="string">&quot;root&quot;</span>;<span class="comment">//本地数据库</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD=<span class="string">&quot;psd&quot;</span>;<span class="comment">//本地数据库配置的密码</span></span><br><span class="line">   <span class="comment">// 数据库连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">sqlConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载jdbc驱动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException exception) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;驱动加载失败&quot;</span>);</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DriverManager.getConnection(URL, NAME, PASSWORD);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库连接成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException exception) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库连接失败&quot;</span>);</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet, Statement statement,Connection connection)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(resultSet!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 resultSet.close();</span><br><span class="line">             &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span>(statement!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                     <span class="keyword">try</span>&#123;</span><br><span class="line">                         statement.close();</span><br><span class="line">                     &#125;<span class="keyword">catch</span> (SQLException e)</span><br><span class="line">                     &#123;</span><br><span class="line">                         e.printStackTrace();</span><br><span class="line">                     &#125;<span class="keyword">if</span>(connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                         <span class="keyword">try</span>&#123;</span><br><span class="line">                             connection.close();</span><br><span class="line">                         &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                             e.printStackTrace();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库已断开连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后使用 Test 类进行测试,没有问题的话数据库连接已经成功了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> database;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Connect().sqlConnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="后端操作数据库"><a href="#后端操作数据库" class="headerlink" title="后端操作数据库"></a>后端操作数据库</h2><p>这里仅举对 user 表进行相关操作的例子，manger 类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Person.User;<span class="comment">//User类封装了user的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Userdatabase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在数据库中查找用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在user表中查询用户信息</span></span><br><span class="line">        String sql=<span class="string">&quot;select * from user where username=&quot;</span>+<span class="string">&quot;&#x27;&quot;</span>+name+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="comment">//连接数据库</span></span><br><span class="line">        Connection connect=Connect.sqlConnect();</span><br><span class="line">        Statement statement=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet=<span class="keyword">null</span>;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement=connect.createStatement();</span><br><span class="line">            resultSet=statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">                <span class="comment">//设置在数据库中找到的用户user</span></span><br><span class="line">                user.setUser_name(resultSet.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">                user.setUser_password(resultSet.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在控制台输出sql语句，方便检验</span></span><br><span class="line">            System.out.println(sql);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException exception)&#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭数据库</span></span><br><span class="line">            <span class="keyword">if</span>(resultSet!=<span class="keyword">null</span>||statement!=<span class="keyword">null</span>||connect!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Connect.close(resultSet,statement,connect);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">user_register</span><span class="params">(String name,String password)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection=Connect.sqlConnect();</span><br><span class="line">        PreparedStatement preparedStatement=<span class="keyword">null</span>;</span><br><span class="line">        String sql=<span class="string">&quot;insert into user(username,password) values(?,?)&quot;</span>;</span><br><span class="line">       <span class="keyword">boolean</span> res=<span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            preparedStatement=connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>,name);</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>,password);</span><br><span class="line">            <span class="keyword">if</span>(preparedStatement.executeUpdate()==<span class="number">1</span>)</span><br><span class="line">                res=<span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(preparedStatement!=<span class="keyword">null</span>)</span><br><span class="line">                    preparedStatement.close();</span><br><span class="line">                <span class="keyword">if</span>(connection!=<span class="keyword">null</span>)</span><br><span class="line">                    connection.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><h3 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;form&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;Login&lt;/h1&gt;</span><br><span class="line">        &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/servlet.Servlet&quot;</span>&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;username&lt;/h2&gt;</span><br><span class="line">                &lt;input</span><br><span class="line">                        type=<span class="string">&quot;text&quot;</span></span><br><span class="line">                        placeholder=<span class="string">&quot;请输入用户名&quot;</span></span><br><span class="line">                        name=<span class="string">&quot;username&quot;</span></span><br><span class="line">                        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pro&quot;</span></span><br><span class="line">                        required=<span class="string">&quot;true&quot;</span></span><br><span class="line">                /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;password&lt;/h2&gt;</span><br><span class="line">                &lt;input</span><br><span class="line">                        type=<span class="string">&quot;password&quot;</span></span><br><span class="line">                        placeholder=<span class="string">&quot;请输入密码&quot;</span></span><br><span class="line">                        name=<span class="string">&quot;password&quot;</span></span><br><span class="line">                        required=<span class="string">&quot;true&quot;</span></span><br><span class="line">                        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pro&quot;</span></span><br><span class="line">                /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;single_choose&quot;</span>&gt;</span><br><span class="line">                &lt;label&gt;用户登录&lt;/label&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;person&quot;</span> value=<span class="string">&quot;user&quot;</span> checked=<span class="string">&quot;checked&quot;</span> /&gt;</span><br><span class="line">                &lt;label&gt;管理员登录&lt;/label&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;person&quot;</span> value=<span class="string">&quot;manger&quot;</span> /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span> /&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;清空&quot;</span> /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-image: url(<span class="string">&quot;https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109170102977.jpg&quot;</span>);</span><br><span class="line">        background-repeat: no-repeat;</span><br><span class="line">        background-size: <span class="number">100</span>% auto;</span><br><span class="line">        <span class="comment">/* background-position:center; */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .login &#123;</span><br><span class="line">        background-color: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.6</span>);</span><br><span class="line">        width: 600px;</span><br><span class="line">        height: 350px;</span><br><span class="line">        margin: <span class="number">0</span> auto;</span><br><span class="line">        margin-top: <span class="number">10</span>%;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        align-items: center;</span><br><span class="line">        text-align: center;</span><br><span class="line">        padding-top: 40px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .form &#123;</span><br><span class="line">        margin: <span class="number">0</span> auto;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        width: 450px;</span><br><span class="line">        height: 250px;</span><br><span class="line">        display: block;</span><br><span class="line">        <span class="comment">/* background-color: aquamarine; */</span></span><br><span class="line">    &#125;</span><br><span class="line">    form div &#123;</span><br><span class="line">        margin-top: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">    h1 &#123;</span><br><span class="line">        color: white;</span><br><span class="line">    &#125;</span><br><span class="line">    h2 &#123;</span><br><span class="line">        color: white;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">        display: inline-block;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input &#123;</span><br><span class="line">        border: none;</span><br><span class="line">        outline: none;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    label &#123;</span><br><span class="line">        color: white;</span><br><span class="line">        font-family: <span class="string">&quot;Courier New&quot;</span>, Courier, monospace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .pro &#123;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">        border-bottom: 2px solid white;</span><br><span class="line">        color: white;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input[type=<span class="string">&quot;submit&quot;</span>] &#123;</span><br><span class="line">        background-color: #414a53;</span><br><span class="line">        color: white;</span><br><span class="line">        width: 80px;</span><br><span class="line">        margin-left: 10px;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    input[type=<span class="string">&quot;submit&quot;</span>]:hover &#123;</span><br><span class="line">        background-color: #80a3c6;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input[type=<span class="string">&quot;reset&quot;</span>] &#123;</span><br><span class="line">        background-color: #414a53;</span><br><span class="line">        color: white;</span><br><span class="line">        width: 80px;</span><br><span class="line">        margin-left: 10px;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input[type=<span class="string">&quot;reset&quot;</span>]:hover &#123;</span><br><span class="line">        background-color: #80a3c6;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    input[type=<span class="string">&quot;radio&quot;</span>]:hover &#123;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><p>路由控制方式有两种:</p><ul><li>web.xml 里配置 servlet 映射</li><li>servlet 注解的方式</li></ul><h4 id="web-xml-配置"><a href="#web-xml-配置" class="headerlink" title="web.xml 配置"></a>web.xml 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet.Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  servlet地址映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet.Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 注意这里的url-pattern要与form表单域中的action一致 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet.Servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/page/login.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="servlet-注解的方式"><a href="#servlet-注解的方式" class="headerlink" title="servlet 注解的方式"></a>servlet 注解的方式</h3><p><strong>使用 servlet 注解就不需要在 web.xml 文件里面写 servlet 映射了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//前端页面的action应与注解的value保持一致</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;servlet.Servlet&quot;, value = &quot;/servlet.Servlet&quot;)</span></span><br></pre></td></tr></table></figure><hr><h2 id="验证登录-注册类似"><a href="#验证登录-注册类似" class="headerlink" title="验证登录(注册类似)"></a>验证登录(注册类似)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Person.User;</span><br><span class="line"><span class="keyword">import</span> database.Userdatabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务登录的servlet</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;servlet.Servlet&quot;, value = &quot;/servlet.Servlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID=<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>.doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">//接收登录的表单信息</span></span><br><span class="line">        String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">//获取登录类型 manger/user</span></span><br><span class="line">        String type = request.getParameter(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(type);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户登录</span></span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;user&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//验证登录</span></span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                user = <span class="keyword">new</span> Userdatabase().findUser(username);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;findUser错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (user.getUser_name() != <span class="keyword">null</span>) &#123;<span class="comment">//用户名正确</span></span><br><span class="line">                <span class="keyword">if</span> (user.getUser_password().equals(password)) &#123;<span class="comment">//密码正确</span></span><br><span class="line">                    HttpSession session = request.getSession();</span><br><span class="line">                    <span class="comment">//封装到session中</span></span><br><span class="line">                    session.setAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">                    session.setAttribute(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">             <span class="comment">//跳转到用户界面，这里注意页面路径的配置，路径不对会显示404</span></span><br><span class="line">                    response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                    response.sendRedirect(<span class="string">&quot;/page/user_index.jsp&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out.println(<span class="string">&quot;用户名错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//管理员登录</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;manger&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//相应功能类似实现</span></span><br><span class="line">        &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Tomcat-配置"><a href="#Tomcat-配置" class="headerlink" title="Tomcat 配置"></a>Tomcat 配置</h2><p>在 Run/Debug Configuration 点击+,选择 Tomcat Server 本地服务，然后点击 Configure 加入本地下载的 tomcat<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110202215427.png"></p><p>修改 Deployment 下的<strong>Application context</strong>为 / (代表当前项目的路径)</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110202221534.png"></p><p>最后启动 Tomcat 服务，测试 Web 程序</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
            <tag> -Servlet </tag>
            
            <tag> -数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv绘图</title>
      <link href="/2021/10/16/opencv%E7%BB%98%E5%9B%BE/"/>
      <url>/2021/10/16/opencv%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><strong>介绍 opencv 中常用的一些绘图函数<br>cv.line()，cv.circle()，cv.rectangle()，cv.ellipse()，cv.putText()等。<br>在上述所有功能中，有一些常见的参数，如下所示:</strong></p><span id="more"></span><ul><li><strong>img</strong>: 要绘制形状的图像</li><li><strong>color</strong>: 形状的颜色。对于 BGR，将其作为元组传递，例如：(255,0,0)蓝色。对于灰度，只需传递标量值即可。</li><li><strong>thickness</strong>: 线条粗细。<strong>如果对闭合图形（如圆）传递-1(或 cv.FILLED)</strong> ，它将填充形状。默认= 1</li><li><strong>lineType</strong>: 线的类型。<br><strong>注意</strong>：这里的 lineType 不是指线型是实线还是虚线等，而是指<strong>线的产生算法</strong>。<ul><li><strong>cv.LINE_AA</strong>：给出了抗锯齿的线条，非常适合曲线。(cv.LINE_AA=16)</li><li><strong>cv.LINE_4</strong>: 4 连通线</li><li><strong>cv.LINE_8</strong>: 8 连通线，默认。</li><li><strong>cv.FILLED</strong>: cv.FILLED=-1</li></ul></li><li><strong>shift</strong>: 缩放参数，会将中心点以及线的长度按比例缩小，d=D/$2^{shift}$</li></ul><hr><h2 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h2><p><code>cv.line(img,pt1,pt2,color,thickness,lineType,shift)</code></p><ul><li>pt1: 开始坐标</li><li>pt2: 结束坐标</li></ul><p>要绘制一条线，需要传递线的开始和结束坐标。我们将创建一个黑色图像，并从左上角到右下角在其上绘制一条蓝线。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 创建height=512,width=512的黑色3通道图像</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"><span class="comment"># 绘制一条粗细为5的蓝色对角线</span></span><br><span class="line">cv.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h2><p><code>cv.rectangle(img,pt1,pt2,color,thickness,lineType,shift)</code></p><ul><li>pt1:矩形的左上角坐标</li><li>pt2:矩形的右下角坐标</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.rectangle(img,(<span class="number">384</span>,<span class="number">0</span>),(<span class="number">510</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h2><p><code>cv.circle(img,center,radius,color,thickness,lineType,shift)</code></p><p>要绘制一个圆，需要其中心坐标和半径。我们将在上面绘制的矩形内绘制一个圆。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv.circle(img,(<span class="number">200</span>,<span class="number">200</span>), <span class="number">67</span>, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 这里因为thickness=-1,所以圆会被填充</span></span><br></pre></td></tr></table></figure><hr><h2 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h2><p><code>cv.ellipse(img,center,axes,angle,startAngle,endAngle,thickness,lineType,shift)</code></p><ul><li>center: 椭圆的中心</li><li>axes: 椭圆的轴长(半长短轴)</li><li>angle:椭圆沿水平方向逆时针旋转的角度</li><li>startAngle:沿长轴顺时针方向开始显示的角度</li><li>endAngle: 沿长轴顺时针结束显示的角度</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.ellipse(img,(<span class="number">220</span>,<span class="number">220</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">360</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h2><p><code>cv.polylines(img,pts,isClosed,color,thickness,lineType,shift)</code></p><ul><li>pts: 顶点数组</li><li>isClosed: 折线是否闭合</li></ul><p>要绘制多边形，首先需要顶点的坐标。将这些点组成形状为 ROWSx1x2 的数组，其中 ROWS 是顶点数，并且其类型应为 int32。在这里，我们绘制了一个带有四个顶点的黄色小多边形。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pts = np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line"><span class="comment">#reshape()函数改变数组的形状，且原始数据不变，参数需要满足乘积等于数组中的数据总数,-1表示未设定行数，由程序计算得出</span></span><br><span class="line">pts = pts.reshape((-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">cv.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 如果第三个参数为 False，将获得一条连接所有点的折线，而不是闭合形状。</p><hr><h2 id="填充多边形"><a href="#填充多边形" class="headerlink" title="填充多边形"></a>填充多边形</h2><p><code>fillPoly()</code>可以填充多个多边形</p><p><code>cv.fillPoly(img,pts,color,lineType,shift)</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pts = np.array([[<span class="number">40</span>, <span class="number">50</span>], [<span class="number">20</span>, <span class="number">30</span>], [<span class="number">70</span>, <span class="number">20</span>], [<span class="number">50</span>, <span class="number">10</span>]], np.int32)</span><br><span class="line">cv.fillPoly(img,[pts],(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="向图像添加文本"><a href="#向图像添加文本" class="headerlink" title="向图像添加文本:"></a>向图像添加文本:</h2><p><code>cv.putText(img,text,org,fontFace, fontScale, color,thickness,lineType,bottomLeftOrigin)</code></p><ul><li>text: 文本内容</li><li>org: 文本框的左下角位置坐标</li><li>fontFace: 字体</li></ul><table><thead><tr><th>常用字体</th><th></th></tr></thead><tbody><tr><td>cv.FONT_HERSHEY_SIMPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_DUPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_PLAIN</td><td></td></tr><tr><td>cv.FONT_HERSHEY_COMPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_TRIPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_COMPLEX_SMALL</td><td></td></tr><tr><td>cv.FONT_HERSHEY_SCRIPT_SIMPLEX</td><td></td></tr><tr><td>cv.FONT_HERSHEY_SCRIPT_COMPLEX</td><td></td></tr></tbody></table><ul><li>fontScale: 字体尺寸</li><li>bottomLeftOrigin： bool 类型，若为 True,org at lower left</li></ul><p>为了获得更好的外观，建议使用 lineType = cv.LINE_AA。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font = cv.FONT_HERSHEY_SIMPLEX</span><br><span class="line">cv.putText(img,<span class="string">&#x27;OpenCV&#x27;</span>,(<span class="number">10</span>,<span class="number">500</span>), font, <span class="number">4</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>,cv.LINE_AA)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变颜色空间</title>
      <link href="/2021/10/16/%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
      <url>/2021/10/16/%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p><strong>对于颜色转换，使用 cv 函数<code>cvtColor(input_img,flag)</code>，其中 flag 决定转换的类型</strong></p><span id="more"></span><h2 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h2><h3 id="BGR-gt-灰度转换"><a href="#BGR-gt-灰度转换" class="headerlink" title="BGR-&gt;灰度转换"></a>BGR-&gt;灰度转换</h3><p>flag: <code>cv.COLOR_BGR2GRAY</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment">#打开摄像头</span></span><br><span class="line">cap=cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;摄像头打开失败&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#逐帧捕获视频图像</span></span><br><span class="line">    tag,frame=cap.read()<span class="comment">#读取到帧，tag返回true,frame为读取到的图像对象</span></span><br><span class="line">    <span class="keyword">if</span> tag==<span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#将读取到的图像进行灰度处理</span></span><br><span class="line">    gray=cv.cvtColor(frame,cv.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment">#显示图像</span></span><br><span class="line">    cv.imshow(<span class="string">&quot;gray&quot;</span>,gray) <span class="comment"># 灰度处理后的图像</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;fram&#x27;</span>,frame) <span class="comment"># 原图像</span></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">5</span>)==<span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="BGR-gt-HSV"><a href="#BGR-gt-HSV" class="headerlink" title="BGR-&gt;HSV"></a>BGR-&gt;HSV</h3><p>flag: <code>cv.COLOR_BGR2HSV</code></p><p>转化方法同上，只需要修改<code>cvtColor(frame,COLOR_BGR2HSV)</code>即可</p><p><strong>注意</strong>: HSV 的色相范围为[0,179],饱和度范围为[0,255],值范围为[0,255]</p><h3 id="获取其他转换的类型标志"><a href="#获取其他转换的类型标志" class="headerlink" title="获取其他转换的类型标志"></a>获取其他转换的类型标志</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">flags=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="built_in">print</span>(flags)</span><br></pre></td></tr></table></figure><p>我们可以看到会打印出一些转换类型的标志，这里我只列举出一部分<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109281725423.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直方图增强实验</title>
      <link href="/2021/10/15/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C(%E4%BA%8C)/"/>
      <url>/2021/10/15/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p><strong>任意两幅灰度图像，显示它们的直方图，并将其中一幅的直方图传递给另一个图像，显示传递后的图像及其直方图</strong></p><span id="more"></span><hr><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>pycharm (python 解释器版本 3.8 ) + opencv</p><hr><h2 id="实验原理与问题分析"><a href="#实验原理与问题分析" class="headerlink" title="实验原理与问题分析"></a>实验原理与问题分析</h2><p>通过一个灰度映像函数，将原灰度直方图改造成所需要的直方图，即直方图规定化。</p><p>步骤:</p><ul><li>将图像进行直方图均衡化处理，求出原图像中每一个灰度级ri所对应的变换函数Si</li><li>对给定直方图做类似计算，得到理想图像中每一个灰度级Zi所对应的函数Vi</li><li>找出Vi近似于Si的像素点，并映射到Zi</li><li>求出目标图像的灰度概率密度Pi(Zi)</li></ul><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算直方图概率分布</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histNormalCalculate</span>(<span class="params">src</span>):</span></span><br><span class="line">    <span class="comment"># src图像的行数和列数</span></span><br><span class="line">    m,n = np.shape(src)</span><br><span class="line">    <span class="comment">#直方图</span></span><br><span class="line">    hist = np.zeros(<span class="number">256</span>,dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            hist[src[i,j]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> hist/(m*n)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算直方图累计概率分布</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histCalculate</span>(<span class="params">src</span>):</span></span><br><span class="line">    m,n = np.shape(src)</span><br><span class="line">    <span class="comment">#直方图</span></span><br><span class="line">    hist = np.zeros(<span class="number">256</span>,dtype=np.float32)</span><br><span class="line">    <span class="comment">#累积直方图</span></span><br><span class="line">    cumhist = np.zeros(<span class="number">256</span>,dtype=np.float32)</span><br><span class="line">    <span class="comment">#累积直方图概率</span></span><br><span class="line">    cumhistPro = np.zeros(<span class="number">256</span>,dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            hist[src[i,j]] += <span class="number">1</span></span><br><span class="line">    cumhist[<span class="number">0</span>] = hist[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">        cumhist[i] = cumhist[i-<span class="number">1</span>]+hist[i]</span><br><span class="line">    cumhistPro = cumhist/(m*n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cumhistPro</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#直方图规定化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histNormalize</span>(<span class="params">img1,img2</span>):</span></span><br><span class="line">    <span class="comment">#计算带匹配直方图</span></span><br><span class="line">    img1Pro = histCalculate(img1)</span><br><span class="line">    <span class="comment">#计算参考直方图</span></span><br><span class="line">    img2Pro = histCalculate(img2)</span><br><span class="line">    <span class="comment"># 匹配映射矩阵</span></span><br><span class="line">    correspondValue = np.zeros(<span class="number">256</span>,dtype=np.uint8)</span><br><span class="line">    <span class="comment">#直方图规定化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        diff = np.<span class="built_in">abs</span>(img1Pro[i]-img2Pro[i])</span><br><span class="line">        matchValue = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="comment"># 找到累积概率最接近的像素</span></span><br><span class="line">            <span class="keyword">if</span> np.<span class="built_in">abs</span>(img1Pro[i] - img2Pro[j]) &lt; diff:</span><br><span class="line">                diff = np.<span class="built_in">abs</span>(img1Pro[i]-img2Pro[j])</span><br><span class="line">                matchValue = j</span><br><span class="line">        correspondValue[i] = matchValue</span><br><span class="line">        <span class="comment"># 查找表</span></span><br><span class="line">    imgOut = cv.LUT(img1,correspondValue)</span><br><span class="line">    <span class="keyword">return</span> imgOut</span><br><span class="line">   <span class="comment"># 绘图</span></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,)</span><br><span class="line">plt.imshow(img1,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img1&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(img2,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img2&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">imgOut = histNormalize(img1,img2)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">plt.imshow(imgOut,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;imgOut&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">hist1 = histNormalCalculate(img1)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">plt.plot(hist1,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img1 hist ratio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">hist2 = histNormalCalculate(img2)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">plt.plot(hist2,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;img2 hist ratio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">hist3 = histNormalCalculate(imgOut)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line">plt.plot(hist3,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;imgOut hist ratio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">plt.hist(img1.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.title(<span class="string">&quot;img1&#x27;s hist&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">plt.hist(img2.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.title(<span class="string">&quot;img2&#x27;s hist&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">plt.hist(imgOut.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.title(<span class="string">&quot;imgout&#x27;s hist&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整子图之间的间距</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110151414597.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像增强实验</title>
      <link href="/2021/10/15/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C(%E4%B8%80)/"/>
      <url>/2021/10/15/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p><strong>用多种图像增强方法完成如下人体骨骼核扫描图的增强任务</strong></p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110151944402.png"></p><p>从上到下从左到右分别为图(a)(b)(e)(f)(c)(d)(g)(h)：<br>(a)原图； (b)图(a)的拉普拉斯变换； (c)图(a)和图(b)相加得到的锐化图像；<br>(d)图(a)的 Sobel 处理； (e)用 5X5 的均值滤波平滑的 Sobel 图像；(f)由(c)和(e)相乘形成的掩蔽图像; (g)由(a)和(f)求和得到的锐化图像; (h)对(g)应用幂律变换得到的最后图像。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>pycharm (python 解释器版本 3.8 ) + opencv</p><hr><h2 id="实验原理与问题分析"><a href="#实验原理与问题分析" class="headerlink" title="实验原理与问题分析"></a>实验原理与问题分析</h2><p>运用图像平滑和梯度的相关知识(见之前发布的相关笔记)</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;Fig.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 拉普拉斯变换</span></span><br><span class="line">laplacian = cv2.Laplacian(img,cv2.CV_64F)</span><br><span class="line"><span class="comment"># sobel处理</span></span><br><span class="line">sobelx = cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobely = cv2.Sobel(img,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 取绝对值</span></span><br><span class="line">sobelx = np.uint8(np.absolute(sobelx))</span><br><span class="line">sobely = np.uint8(np.absolute(sobely))</span><br><span class="line"><span class="comment"># 对图像每个像素值进行二进制或运算</span></span><br><span class="line">sobelCom = cv2.bitwise_or(sobelx,sobely)</span><br><span class="line"><span class="comment"># add</span></span><br><span class="line">C = img+laplacian</span><br><span class="line"><span class="comment"># 均值滤波</span></span><br><span class="line">E = cv2.blur(sobelCom,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment"># ×</span></span><br><span class="line">F = C*E</span><br><span class="line">mina = np.<span class="built_in">min</span>(F)</span><br><span class="line">maxa = np.<span class="built_in">max</span>(F)</span><br><span class="line"><span class="comment">#print(mina,maxa)</span></span><br><span class="line">F = np.uint8(<span class="number">255</span>*(F-mina)/(maxa-mina))</span><br><span class="line"></span><br><span class="line">G = img+F</span><br><span class="line"><span class="comment"># 幂律变换</span></span><br><span class="line">H = cv2.<span class="built_in">pow</span>(G/<span class="number">255.0</span>,<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>),plt.imshow(img,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;A = original&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>),plt.imshow(laplacian,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;B = laplacian&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>),plt.imshow(C,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;C = add a and b&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>),plt.imshow(sobelCom,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;D = sobel&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>),plt.imshow(E,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;E = blur sobel&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>),plt.imshow(F,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;F = C*E&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>),plt.imshow(G,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;G = add a and f&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>),plt.imshow(H,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;H = mi lv&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110151947674.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像几何变换</title>
      <link href="/2021/10/08/%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
      <url>/2021/10/08/%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><strong>图像的几何变换是图像处理的基础之一，通过几何变换不仅可以产生一些特殊的效果，而且可以简化图像处理过程和分析程序。图像的几何变换最重要的特征是仅改变像素的位置，而不改变图像的像素值。图像的几何变换按性质可以分为图像的位置变换(平移、镜像、旋转)、图像的形状变换(放大、缩小、错切)等基本变换,以及图像的复合变换等。</strong></p><span id="more"></span><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>原理:</p><p>设原图像中的点 $p_{0}$($x_{0}$,$y_{0}$) 按一定比例缩放后，在新图像中的对应点为 P(x,y),则两者之间有如下对应关系</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081931471.png"></p><p><strong>注意</strong>: 如果图像在 x 轴和 y 轴方向缩放的比例不相同，则图像会产生<strong>几何畸变</strong>。</p><hr><p>代码:</p><p><code>cv.resize(src,dsize,dst,fx,fy,interpolation)</code></p><ul><li><p>src: 原图像</p></li><li><p>dsize: 目标图像尺寸，必须为<strong>整型</strong></p></li><li><p>dst: 目标图像</p></li><li><p>fx: 水平轴缩放比例</p></li><li><p>fy: 竖直轴缩放比例</p></li><li><p>interpolation: 插值方法</p><ul><li><code>INTER_NEAREST</code> 最邻近插值法</li><li><code>INTER_LINEAR</code> 双线性插值法(默认)</li><li><code>INTER_AREA</code> 基于局部像素的重采样</li><li><code>INTER_CUBIC</code> 基于 4×4 像素邻域的 3 次插值法</li><li><code>INTER_LANCZOS4</code> 基于 8×8 像素邻域的 Lanczos 插值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 这里将图像放大2倍</span></span><br><span class="line">res=cv.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 还可以通过另一种方式</span></span><br><span class="line"><span class="comment"># height,width=img.shape[:2]</span></span><br><span class="line"><span class="comment"># res=cv.resize(img,(width*2,height*2),cv.INTER_LINEAR)</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;resize&#x27;</span>,res)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081640790.png"></p><hr><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>原理:</p><p>设原图像中的点 $p_{0}$($x_{0}$,$y_{0}$) 经过平移变换后，在新图像中的对应点为 P(x,y),则两者之间有如下对应关系</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081950228.png"></p><hr><p>代码:</p><p><code>cv.wrapAffine(src,M,dsize,dst,flags,borderMode,borderValue)</code></p><ul><li><p>M: 变换矩阵</p></li><li><p>flags: 插值方法，同上述缩放变换中的表示</p></li><li><p>borderMode: 边界像素模式，默认为<code>BORDER_CONSTANT</code>,边界按常数填充</p><ul><li>cv.BORDER_CONSTANT: 添加有颜色的常数值边界，通过 borderValue 设置</li><li>cv.BORDER_REFLECT: 边界元素的镜像</li><li>cv.BORDER_REFLECT_101 或 cv.BORDER_DEFAULT 同上，只是处理方式稍有不同</li><li>cv.BORDER_REPLICATE: 重复最后一个元素</li><li>cv.BORDER_WRAP</li></ul></li><li><p>borderValue: 边界填充值，默认为 0，即填充黑色</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line"><span class="comment"># 图像的高度和宽度</span></span><br><span class="line">height,width=img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 使用numpy数组构造平移矩阵(数据类型为float32),设置x和y方向上平移量均为50</span></span><br><span class="line">M=np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">50</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])</span><br><span class="line">res=cv.warpAffine(img,M,(width,height))</span><br><span class="line">cv.imshow(<span class="string">&#x27;move&#x27;</span>,res)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081648866.png"></p><p>通过处理结果，我们发现由于没有扩大图像，平移后图像的部分数据会丢失。</p><hr><h2 id="镜像变换"><a href="#镜像变换" class="headerlink" title="镜像变换"></a>镜像变换</h2><p>图像的镜像变换分为水平镜像和垂直镜像。</p><p>代码:</p><p><code>cv.flip(src,dst,flip_mod)</code></p><ul><li>flip_mode: 图像镜像变换的方式<ul><li>flip_mode=0,表示沿 x 轴进行翻转</li><li>flip_mode&gt;0,表示沿 Y 轴进行翻转</li><li>flip_mode&lt;0,表示沿 x 和 y 轴进行翻转</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line"><span class="comment"># 沿x轴进行翻转</span></span><br><span class="line">dstx=cv.flip(img,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 沿y轴进行翻转</span></span><br><span class="line">dsty=cv.flip(img,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 沿xy轴进行翻转</span></span><br><span class="line">dstxy=cv.flip(img,-<span class="number">1</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dstx&#x27;</span>,dstx)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dsty&#x27;</span>,dsty)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dstxy&#x27;</span>,dstxy)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110071735691.png"></p><hr><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>原理:</p><p>设原图像中的点 $p_{0}$($x_{0}$,$y_{0}$)旋转$\theta$角后，在新图像中的对应点为 P(x,y),则两者之间有如下对应关系</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110082021030.png"></p><hr><p>代码:</p><p><code>cv.getRotationMatrix2D(center,angle,scale)</code></p><ul><li>center: 原图像的旋转中心</li><li>angle: 图像旋转角度，角度为正则表示逆时针旋转</li><li>scale: 缩放系数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取图像高度和宽度</span></span><br><span class="line">height,width=img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 设置旋转矩阵,30为旋转度数</span></span><br><span class="line">M=cv.getRotationMatrix2D((width/<span class="number">2</span>,height/<span class="number">2</span>),<span class="number">30</span>,<span class="number">1</span>)</span><br><span class="line">rotate=cv.warpAffine(img,M,(width,height),cv.INTER_LINEAR)</span><br><span class="line">cv.imshow(<span class="string">&#x27;rotate&#x27;</span>,rotate)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110081705115.png"></p><p><strong>注意</strong>:</p><p>1.为避免丢失图像信息，可以通过<strong>设置旋转中心</strong>、<strong>缩放因子</strong>、<strong>调整窗口大小</strong>等方法</p><p>2.图像旋转后，因为坐标取值的不同，图像会出现空洞点，因此需要对空洞点进行填充处理，否则边缘将会出现锯齿影响图像质量。处理的方法可以通过<strong>插值</strong>处理。</p><hr><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>上面提到的平移和旋转都是仿射变换的特例。</p><p>原理:</p><p>在仿射变换中，原始图像中的所有平行线在输出图像中仍将平行。<br>为了找到变换矩阵 M，我们需要输入图像中的三个点及其在输出图像中的对应位置。<br>然后通过<strong>cv.getAffineTransform()<strong>找到一个</strong>2x3 变换矩阵 M</strong>，再将该矩阵将传递给**cv.warpAffine()**进行处理</p><hr><p>代码:</p><p><code>cv.getAffineTransform(src,dst)</code></p><ul><li>src: 原图中三个点所组成的矩阵,数据类型为<code>np.float32</code></li><li>dst: 目标图像中对应的 3 个点所组成的矩阵，数据类型为<code>np.float32</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=cv.imread(<span class="string">&#x27;change.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取图像的宽、高</span></span><br><span class="line">height,width=img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 原图像三个点和目标图像三个点的位置，数据类型为np.float32</span></span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">10</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">100</span>,<span class="number">250</span>]])</span><br><span class="line"><span class="comment"># 通过getAffineTransform()找到2×3的转换矩阵M</span></span><br><span class="line">M = cv.getAffineTransform(pts1,pts2)</span><br><span class="line"><span class="comment"># 将转换矩阵M传递给warpAffine()函数</span></span><br><span class="line">dst = cv.warpAffine(img,M,(width,height))</span><br><span class="line"><span class="comment"># 使用python绘图库绘制图像</span></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Input&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Output&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110082042140.png"></p><hr><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>空间坐标系中的三维物体或对象转变为二维图像的过程称为投影变换，根据投影中心(视点)与投影平面之间距离的不同，投影可以分为平行投影和透视投影。<br>透视投影即透视变换，透视投影的中心到投影平面之间的距离是有限的，具有<strong>透视缩小效应</strong>的特点，即三维物体或对象透视投影的大小与形体到投影中心的距离成反比。</p><p>原理:</p><p>对于透视变换，需要 3x3 变换矩阵。即使在转换后，直线也将保持直线。要找到此变换矩阵，需要在输入图像上有 4 个点，<br>在输出图像上需要相应的点。在这四个点中，其中<strong>三个不应共线</strong>。<br>然后可以通过函数 <strong>cv.getPerspectiveTransform()</strong> 找到变换矩阵。<br>再调用 <strong>cv.warpPerspective()</strong> 应用 3x3 转换矩阵</p><p><strong>关键</strong>:找到对应的转换矩阵 M</p><hr><p>代码:</p><p><code>cv.warpPerspective(src,M,dsize,dst,flags,borderMode,borderValue)</code></p><ul><li>M: 转换矩阵</li><li>flags: 插值方法，同上</li><li>borderMode: 边界像素模式,同上</li></ul><p>转换矩阵的获取:</p><p><code>cv.getPerspectiveTransform(src,dst)</code></p><ul><li>src: 原图像中 4 个点组成的矩阵，数据类型为<code>np.float32</code></li><li>dst: 目标图像中对应 4 个点组成的矩阵，数据类型为<code>np.float32</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;change.png&#x27;</span>)</span><br><span class="line">pts1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line">M = cv.getPerspectiveTransform(pts1,pts2)</span><br><span class="line">dst = cv.warpPerspective(img,M,(<span class="number">300</span>,<span class="number">300</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Input&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Output&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110082107328.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像形态学</title>
      <link href="/2021/10/05/%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%80%81%E5%AD%A6/"/>
      <url>/2021/10/05/%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%80%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>数学形态学是图像处理的重要工具，可用于获取<strong>图像边界</strong>、<strong>提取骨架</strong>、<strong>去除噪声</strong>和<strong>检测角点</strong>，其应用覆盖<br><strong>文字识别</strong>、<strong>视觉检测</strong>和<strong>医学图像处理</strong>等领域。</p><p>形态变换是一些基于图像形状的简单操作。形态学处理主要针对的是<strong>二值图像</strong>(在图像中任何像素点的灰度值只有 0 或 255)</p><p>两种基本的形态学算子是<strong>腐蚀</strong>和<strong>膨胀</strong>。</p><span id="more"></span><h2 id="结构元素-内核"><a href="#结构元素-内核" class="headerlink" title="结构元素(内核)"></a>结构元素(内核)</h2><p>在考察目标图像各部分之间的关系时，需要设计一种收集信息的“探针”，即结构元素。</p><ul><li><p>在图像中不断移动结构元素，就可以考察图像中各部间的关系。</p></li><li><p>结构元素的形状包括<strong>矩形</strong>、<strong>十字形</strong>、<strong>椭圆形和菱形</strong>等，如果结构元素长宽相等，矩形和椭圆形将退化为<strong>正方形</strong>和<strong>圆形</strong>。</p></li><li><p>一般来说，结构元素尺寸要明显小于目标图像的尺寸，选择不同形状和尺寸的结构元素可提取图像中的不同特征。</p></li><li><p>结构元素本身也是一个<strong>图像</strong>集合，对于结构元素可以指定一个原点，将其作为结构元素参与形态学运算的参考点。原点可包含在结构元素中，也可不包含在结构元素中。</p></li></ul><h2 id="腐蚀操作"><a href="#腐蚀操作" class="headerlink" title="腐蚀操作"></a>腐蚀操作</h2><p>原理:</p><p>腐蚀是一种最基本的数学形态学运算，对给定的目标图像 X 和结构元素 S，将 S 在图像上移动，则对于每一个当前位置 x 有</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051518952.png"></p><p>即 S 对 X 腐蚀的结果是<strong>S 完全包含在 X 中时 S 的原点位置的集合</strong>。</p><p>原始图像中的一个像素(无论是 1 还是 0)只有当内核下的所有像素都是 1 时才被认为是 1，否则它就会被侵蚀(变成 0)。<br>根据内核的大小，边界附近的所有像素都会被丢弃。<br>因此，前景物体的厚度或大小减小，或只是图像中的白色区域减小。它有助于去除小的白色噪声，分离两个连接的对象。</p><hr><p>代码:</p><p>OpenCV 中采用 <code>getStructuringElement()</code>和<code>erode()</code>函数实现结构元素的设定和图像腐蚀操作</p><p><code>cv2.getStructuringElement(eleType,ksize,point)</code></p><ul><li><p>eleType: 结构元素类型,OpenCV 中定义了 3 种基本结构元素形状</p><pre><code> · MORPH_RECT  矩形 . MORPH_CROSS  十字形 . MORPH_ELLIPSE 椭圆形</code></pre></li><li><p>ksize: 结构元素大小</p></li><li><p>point: 锚点(结构元素中心点)位置</p></li></ul><p><code>dst=cv2.erode(src,kernel,iterations)</code></p><ul><li>kernel: 卷积核</li><li>iterations: 迭代次数，默认为 1</li></ul><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;pic.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 通过getStructuringElement()设置结构元素</span></span><br><span class="line">kernel=cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 还可以通过np.ones()函数设置卷积核</span></span><br><span class="line"><span class="comment"># kernel=np.ones((3,3),np.uint8)</span></span><br><span class="line"><span class="comment"># 腐蚀</span></span><br><span class="line">erosion=cv.erode(img,kernel,iterations=<span class="number">2</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;erosion&#x27;</span>,erosion)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051536199.png"></p><p>对比处理结果我们发现原图像中的白色噪声被腐蚀掉了。</p><hr><h2 id="膨胀操作"><a href="#膨胀操作" class="headerlink" title="膨胀操作"></a>膨胀操作</h2><p>原理:</p><p>对给定的目标图像 X 和结构元素 S，将 S 在图像上移动，则对于每一个当前位置 x 有</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051610462.png"></p><p>即用 S 来膨胀 X 得到的集合是 <strong>$S^{v}$的平移与 X 至少有一个公共的非零元素相交时，S 的原点位置的集合</strong></p><p>($S^{v}$指 S 关于原点的映射)</p><p>与腐蚀操作相反(腐蚀虽然消除了白噪声，但也会压缩图像)，<strong>但并不是互为逆运算</strong>，<br>如果内核下至少有一个像素为“ 1”，则像素元素为“ 1”，图像就会膨胀。因此，它会增加图像中的白色区域或增加前景对象的大小。</p><hr><p>代码:</p><p><code>dst=cv.dilate(src,kernel,iterations)</code></p><ul><li>kernel: 卷积核</li><li>iterations: 迭代次数，默认为 1，进行一次膨胀</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;pic.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用numpy库生成卷积核</span></span><br><span class="line">kernel=np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion=cv.erode(img,kernel,iterations=<span class="number">2</span>)<span class="comment"># 腐蚀</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;erosion&#x27;</span>,erosion)</span><br><span class="line"><span class="comment"># 膨胀</span></span><br><span class="line">k=np.ones((<span class="number">3</span>,<span class="number">3</span>),np.uint8) <span class="comment"># 使用3*3的卷积核</span></span><br><span class="line">dliate=cv.dilate(erosion,k)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dilate&#x27;</span>,dliate)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051621873.png"></p><p>这里我们将腐蚀过后的二值图像进行膨胀操作</p><hr><p><strong>由于腐蚀和膨胀并不是互为逆运算，所以它们可以结合使用。在腐蚀和膨胀两个基本运算的基础上，可以构造出形态学运算簇</strong></p><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><p>先对图像进行腐蚀然后膨胀其结果，称为开运算。对于消除噪音很有用</p><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pic2=cv.imread(<span class="string">&#x27;pic2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 开运算</span></span><br><span class="line">k=np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erode1=cv.erode(pic2,k,iterations=<span class="number">1</span>)</span><br><span class="line">dilate1=cv.dilate(erode1,k)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,pic2)</span><br><span class="line">cv.imshow(<span class="string">&#x27;open&#x27;</span>,dilate1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>或 <code>open= cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</code></p><hr><p>处理结果:<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051721256.png"></p><hr><h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><p>先对图像进行膨胀然后腐蚀其结果，称为闭运算。</p><p>在关闭前景对象内部的小孔或对象上的小黑点时很有用。</p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pic1=cv.imread(<span class="string">&#x27;pic1.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">k=np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"><span class="comment"># 闭运算</span></span><br><span class="line">dilate2=cv.dilate(pic1,k)</span><br><span class="line">erode2=cv.erode(dilate2,k,iterations=<span class="number">1</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,pic1)</span><br><span class="line">cv.imshow(<span class="string">&#x27;close&#x27;</span>,erode2)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>或 <code>close = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</code></p><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051725253.png"></p><hr><h2 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h2><p>图像膨胀与腐蚀运算之差</p><p>可以用形态学梯度来突出边缘，保留物体的边缘轮廓</p><hr><p><code>gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</code></p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051822445.png"></p><h2 id="顶帽"><a href="#顶帽" class="headerlink" title="顶帽"></a>顶帽</h2><p>原图与开运算之差</p><p><code>tophat = cv.morphologyEx(src, cv.MORPH_TOPHAT, kernel)</code></p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051801306.png"></p><h2 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h2><p>闭运算与原图之差</p><p><code>blackhat = cv.morphologyEx(src, cv.MORPH_BLACKHAT, kernel)</code></p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110051805540.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像梯度</title>
      <link href="/2021/10/02/%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/"/>
      <url>/2021/10/02/%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>图像梯度是指图像某像素在x和y两个方向上的变化率(与相邻像素比较)，本质上即导数。</strong></p><span id="more"></span><h2 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h2><p>Sobel算子是高斯平滑加微分运算的联合运算，因此它更抗噪声</p><p><strong>Sobel算子常用模板</strong><br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021349749.png"></p><hr><p>代码:</p><p><code>dst=cv.Sobel(src,ddepth,dx,dy,ksize)</code></p><ul><li>ddepth: 输出图像的深度，若使用-1，则与原图像深度保持一致<code>numpy.uint8</code>,输出图像的深度必须大于等于原图像的深度</li><li>dx和dy分别表示导数方向为水平和竖直方向，0表示此方向不求导</li><li>kszie: Sobel算子的大小，如果ksize = -1，则使用3x3 Scharr滤波器，比3x3 Sobel滤波器具有更好的结果，必须为1，3，5，7</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;test.png&#x27;</span>,cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># 在x方向求导</span></span><br><span class="line">sobelx=cv.Sobel(img,cv.CV_8U,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 取绝对值，转回原来的uint8形式</span></span><br><span class="line">sobelx=cv.convertScaleAbs(sobelx)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;sobelx&#x27;</span>,sobelx)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>处理结果:<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021812235.png"></p><hr><p>从上面的处理结果我们会发现一个问题 :<strong>右边的边缘信息被忽略了.</strong></p><p>造成此种情况的原因在于<strong>黑色到白色的过渡被视为正斜率（具有正值），而白色到黑色的过渡被视为负斜率（具有负值），此时若设置输出图像的深度为<code>cv.CV_8U</code>或<code>numpy.uint8</code>,则所有的负值都会被截断为0(所建立的图像位数不够，会被截断为0),边界将会丢失。</strong></p><p><strong>解决方案</strong>: 如果要检测两个边缘，更好的选择是将输出数据类型保留为更高的形式，例如<code>cv.CV_16S</code>，<code>cv.CV_64F</code>等，取其绝对值，然后转换回<code>cv.CV_8U</code>。</p><p><strong>注意</strong>:取绝对值的步骤也同样需要，否则边缘也同样会丢失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;test.png&#x27;</span>,cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># CV_64F 表示输出图像的深度</span></span><br><span class="line"><span class="comment"># 在x方向求导</span></span><br><span class="line">sobelx=cv.Sobel(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>) </span><br><span class="line">sobelx=cv.convertScaleAbs(sobelx)</span><br><span class="line"><span class="comment"># 在y方向求导</span></span><br><span class="line">sobely=cv.Sobel(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobely=cv.convertScaleAbs(sobely)</span><br><span class="line"><span class="comment"># x和y方向按权求和</span></span><br><span class="line">sobelxy=cv.addWeighted(sobelx,<span class="number">0.5</span>,sobely,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;sobelx&#x27;</span>,sobelx)</span><br><span class="line">cv.imshow(<span class="string">&#x27;sobely&#x27;</span>,sobely)</span><br><span class="line">cv.imshow(<span class="string">&#x27;sobelxy&#x27;</span>,sobelxy)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021442542.png"></p><hr><h2 id="Scharr算子"><a href="#Scharr算子" class="headerlink" title="Scharr算子"></a>Scharr算子</h2><p>Scharr是对Sobel算子(使用小的卷积核求解梯度角度时)的优化。</p><p><strong>卷积核</strong><br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021417584.png"></p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;test.png&#x27;</span>,cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># x方向求导</span></span><br><span class="line">scharrx=cv.Scharr(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,scale=<span class="number">3</span>)</span><br><span class="line">scharrx=cv.convertScaleAbs(scharrx)</span><br><span class="line"><span class="comment"># y方向求导</span></span><br><span class="line">scharry=cv.Scharr(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,scale=<span class="number">3</span>)</span><br><span class="line">scharry=cv.convertScaleAbs(scharry)</span><br><span class="line"><span class="comment"># x和y方向按权求和</span></span><br><span class="line">scharrxy=cv.addWeighted(scharrx,<span class="number">0.5</span>,scharry,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;x&#x27;</span>,scharrx)</span><br><span class="line">cv.imshow(<span class="string">&#x27;Y&#x27;</span>,scharry)</span><br><span class="line">cv.imshow(<span class="string">&#x27;xy&#x27;</span>,scharrxy)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021433511.png"></p><hr><h2 id="laplacian算子"><a href="#laplacian算子" class="headerlink" title="laplacian算子"></a>laplacian算子</h2><p>拉普拉斯算子是一种各向同性的二阶微分算子，在(x，y)处的值定义为:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021931521.png"></p><p>当<strong>ksize=1</strong>时，拉普拉斯滤波器使用的卷积核:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021437477.png"></p><p>其他常用的拉普拉斯模板:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021620633.png"><br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021622506.png"></p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;test.png&#x27;</span>)</span><br><span class="line">laplacian=cv.Laplacian(img,cv.CV_64F)</span><br><span class="line">laplacian=cv.convertScaleAbs(laplacian)</span><br><span class="line">cv.imshow(<span class="string">&#x27;laplacian&#x27;</span>,laplacian)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021457598.png"></p><hr><h2 id="不同算子之间比较"><a href="#不同算子之间比较" class="headerlink" title="不同算子之间比较"></a>不同算子之间比较</h2><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>,cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># Sobel算子</span></span><br><span class="line">sobelx=cv.Sobel(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobelx=cv.convertScaleAbs(sobelx)</span><br><span class="line">sobely=cv.Sobel(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">3</span>)</span><br><span class="line">sobely=cv.convertScaleAbs(sobely)</span><br><span class="line">sobelxy=cv.addWeighted(sobelx,<span class="number">0.5</span>,sobely,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># Scharr算子</span></span><br><span class="line">scharrx=cv.Scharr(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,scale=<span class="number">3</span>)</span><br><span class="line">scharrx=cv.convertScaleAbs(scharrx)</span><br><span class="line">scharry=cv.Scharr(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,scale=<span class="number">3</span>)</span><br><span class="line">scharry=cv.convertScaleAbs(scharry)</span><br><span class="line">scharrxy=cv.addWeighted(scharrx,<span class="number">0.5</span>,scharry,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># Laplacian算子</span></span><br><span class="line">laplacian=cv.Laplacian(img,cv.CV_64F)</span><br><span class="line">laplacian=cv.convertScaleAbs(laplacian)</span><br><span class="line"></span><br><span class="line">res=np.hstack((img,sobelxy,scharrxy,laplacian))</span><br><span class="line">cv.imshow(<span class="string">&#x27;all&#x27;</span>,res)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>对比:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202110021507528.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像平滑</title>
      <link href="/2021/09/30/%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91/"/>
      <url>/2021/09/30/%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91/</url>
      
        <content type="html"><![CDATA[<p><strong>图像平滑是一种区域增强算法，在图像产生、传输和复制的过程中，会因为多方面原因而产生噪声(某一像素与周围像素点相比有明显不同)或丢失数据，因而图像的质量会降低。此时就需要对图像进行一定的增强处理，以降低图像质量带来的影响</strong></p><span id="more"></span><h2 id="图像噪声"><a href="#图像噪声" class="headerlink" title="图像噪声"></a>图像噪声</h2><p>图像噪声使得图像模糊，甚至淹没图像特征，造成分析困难。</p><p>常见的噪声分类:</p><ul><li>产生原因: 外部噪声、内部噪声</li><li>统计特征: 平稳噪声 非平稳噪声</li><li>幅度分布: 高斯噪声 椒盐噪声</li><li>噪声频谱: 白噪声 1/f 噪声</li><li>噪声与信号之间的关系: 加性噪声 乘性噪声</li></ul><hr><h2 id="模板卷积"><a href="#模板卷积" class="headerlink" title="模板卷积"></a>模板卷积</h2><p>模板操作是图像处理中常用的一种邻域运算方式，主要有<strong>卷积</strong>和<strong>相关</strong>操作。</p><ul><li><p>模板:</p><p>常用矩阵表示，可以是一幅图像、一个滤波器或一个窗口，定义了参与运算的中心元素和邻域元素的相对位置及相关系数。<br>模板的中心元素(原点)表示将要处理的元素，一般取模板中心点，也可以根据需要选取非中心点。</p></li><li><p>模板卷积(或相关):</p><p>指模板与图像进行卷积(或相关)运算，是一种线性滤波，其输出像素是输入邻域像素的线性加权和。</p></li><li><p>卷积核:</p><p>模板卷积中的模板又称为卷积核，其元素称为卷积系数、模板系数或加权系数，其大小及排列顺序决定了对图像进行邻域处理的类型。</p></li></ul><p>卷积运算前需要将模板绕模板中心旋转 180°，其余运算过程与模板运算过程一致，因而统称模板卷积。</p><p>模板操作需要注意的两个问题:</p><ul><li><p>图像边界问题</p><p>当模板原点移至图像边界时，部分模板系数可能在原图像中找不到与之对应的像素。</p><p>解决方法:</p><p>1.不做处理</p><p>2.扩充图像</p><p>可以复制原图像边界像素或利用常数来填充扩充的像素边界</p></li><li><p>计算结果可能超出灰度范围</p></li></ul><hr><h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p>原理: 用一个像素邻域平均值作为滤波结果，此时滤波器模板的所有系数取值均为 1，仅获取内核区域下所有像素的平均值，并替换中心元素，为保证输出像素值不越界，邻域平均的卷积核系数之和为 1</p><hr><p>计算思路:</p><p>例如下图中，我们要计算红色点经过均值滤波后的像素值，蓝色区域 3×3 的矩阵为核，采用核处理后，红色点的像素值=<strong>(100+210+123+123+220+231+45+21+32)/9</strong></p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301159958.png"></p><hr><p>均值滤波常用的一个 3×3 的 Box 模板(还有 5×5 等等),Box 模板中加权系数均相同，邻域中各像素对平滑结果的影响相同。</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301137811.png"></p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">blur=cv.blur(img,(<span class="number">3</span>,<span class="number">3</span>)) <span class="comment">#(3×3)为核大小</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;blur&#x27;</span>,blur)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292310023.png"></p><hr><h2 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h2><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">box=cv.boxFilter(img,-<span class="number">1</span>,(<span class="number">3</span>,<span class="number">3</span>),normalize=<span class="literal">True</span>) <span class="comment"># -1 表示颜色通道一致，(3,3)表示卷积核的大小 normalize表示归一化，如果选择归一化，则和均值滤波是一样的</span></span><br><span class="line">box2=cv.boxFilter(img,-<span class="number">1</span>,(<span class="number">3</span>,<span class="number">3</span>),normalize=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># normalize为false，不进行归一化处理，此时模板内像素进行处理时可能会发生越界的情况(即超过最大的像素值255),越界的情况会直接取最大值255</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;boxfilter1&#x27;</span>,box)</span><br><span class="line">cv.imshow(<span class="string">&#x27;box2&#x27;</span>,box2)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果(进行归一化):</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292336627.png"></p><p>处理结果(不进行归一化):</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292315254.png"></p><hr><h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p>原理:</p><ul><li>高斯模板是通过对二维高斯函数进行采样(高斯模糊的卷积核里的数值满足高斯分布)、量化并归一化得到的，它考虑了邻域像素位置的影响，距离当前被平滑像素越近的点，加权系数越大，将加权平均值作为中心像素的输出结果。</li><li>加权的目的在于减轻平滑过程中造成的图像模糊</li><li>高斯模糊对于从图像中去除高斯噪声非常有效</li></ul><p>高斯滤波常用的一个 3×3 模板</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301226649.png"></p><hr><p>代码:</p><p><strong>cv.GaussianBlur(src,ksize,sigmaX,sigmaY)</strong></p><ul><li>ksize:卷积核大小</li><li>sigmaX:X 方向标准偏差</li><li>sigmaY:Y 方向标准偏差</li></ul><p>如果仅指定 sigmaX，则将 sigmaY 与 sigmaX 相同。如果两个都为零，则根据内核大小进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">gauss=cv.GaussianBlur(img,(<span class="number">7</span>,<span class="number">7</span>),<span class="number">0</span>)<span class="comment"># (7,7)为卷积核大小</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;gauss&#x27;</span>,gauss)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292322264.png"></p><hr><h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p>中值滤波是一种非线性滤波，它能在滤除噪声的同时很好地保持图像边缘。</p><p>原理: 以某像素为中心的窗口内所有像素的灰度按从小到大排序，取排序结果的中间值作为该像素的灰度值。</p><hr><p>计算思路:</p><p>例如我们以 220 为中心选取了一个 3×3 的窗口，此时对窗口内所有像素按灰度大小进行排序，取中间值 123 作为中值滤波后的像素值。<br><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301306976.png"></p><hr><p>代码:</p><p><strong>cv.medianBlur(src,ksize)</strong></p><ul><li>ksize:表示卷积核大小，必须是一个<strong>大于 1 的奇数</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">media=cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;media&#x27;</span>,media)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109292326292.png"></p><hr><h2 id="上述滤波处理对比"><a href="#上述滤波处理对比" class="headerlink" title="上述滤波处理对比"></a>上述滤波处理对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;noise.jpg&#x27;</span>)</span><br><span class="line">blur=cv.blur(img,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">gauss=cv.GaussianBlur(img,(<span class="number">7</span>,<span class="number">7</span>),<span class="number">0</span>)</span><br><span class="line">media=cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">res=np.hstack((img,blur,gauss,media)) <span class="comment"># 水平拼接所有图像</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;all&#x27;</span>,res)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109301319618.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像阈值</title>
      <link href="/2021/09/28/%E5%9B%BE%E5%83%8F%E9%98%88%E5%80%BC/"/>
      <url>/2021/09/28/%E5%9B%BE%E5%83%8F%E9%98%88%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><strong>阈值又叫临界值，是指一个效应能够产生的最低值或最高值</strong></p><span id="more"></span><h2 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h2><p><code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code></p><ul><li><p>src: 输入图，注意只能是单通道图像，通常使用灰度图</p></li><li><p>ret: 返回阈值</p></li><li><p>dst: 输出图</p></li><li><p>thresh: 阈值</p></li><li><p>maxval: 当图像像素值超过了阈值(或者小于阈值，根据 type 来决定)所赋予的值</p></li><li><p>type: 二值化操作的类型，包括五种类型:</p><p><code>cv2.THRESH_BINARY</code>:超过阈值部分取 maxval(最大值)，低于阈值部分取 0</p><p><code>cv.THRESH_BINARY_INV</code>:低于阈值部分取 maxval(最大值)，超过阈值部分取 0</p><p><code>cv.THRESH_TRUNC</code>: 大于阈值部分设为阈值，否则不变</p><p><code>cv.THRESH_TOZERO</code>: 大于阈值部分不变，否则为 0</p><p><code>cv2.THRESH_TOZERO_INV</code>: 低于阈值部分不变，否则为 0</p></li></ul><hr><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 图像灰度处理</span></span><br><span class="line">gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 简单阈值处理</span></span><br><span class="line">ret,dst1=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,dst2=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,dst3=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,dst4=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,dst5=cv.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,gray)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst1&#x27;</span>,dst1)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst2&#x27;</span>,dst2)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst3&#x27;</span>,dst3)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst4&#x27;</span>,dst4)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst5&#x27;</span>,dst5)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>不同简单阈值类型的对比</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109281837906.png"></p><hr><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>如果图像在不同区域具有不同的光照条件。在这种情况下，自适应阈值效果更好。算法基于像素周围的小区域确定像素的阈值，因此，对于同一图像的不同区域，我们获得了不同的阈值，<br>这为光照度变化的图像提供了更好的结果。</p><hr><p><code>dst=cv2.adaptiveThreshold(src,maxValue,adaptiveMethod,thresholdType,blockSize,C)</code></p><ul><li><p>src: 输入图，注意只能是单通道图像，通常使用灰度图</p></li><li><p>dst: 输出图</p></li><li><p>maxValue: 当图像像素值超过了阈值(或者小于阈值，根据 thresholdType 来决定)所赋予的值</p></li><li><p>adaptiveMethd: 决定阈值是如何计算的</p><p><code>cv2.ADAPTIVE_THRESH_MEAN_C</code>:阈值是邻近区域的平均值减去常数<strong>C</strong>。</p><p><code>cv2.ADAPTIVE_THRESH_GAUSSIAN_C</code>:阈值是邻域值的高斯加权总和减去常数<strong>C</strong></p></li><li><p>thresholdType:</p><p><code>cv2.THRESH_BINARY</code>:超过阈值部分取 maxval(最大值)，低于阈值部分取 0</p><p><code>cv.THRESH_BINARY_INV</code>:低于阈值部分取 maxval(最大值)，超过阈值部分取 0</p></li><li><p>blockSize: 确定附近区域的大小</p></li><li><p>C:是从邻域像素的平均或加权总和中减去的一个常数</p></li></ul><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 图像灰度处理</span></span><br><span class="line">gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 自适应阈值处理</span></span><br><span class="line">dst=cv.adaptiveThreshold(gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">25</span>,<span class="number">5</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,gray)</span><br><span class="line">cv.imshow(<span class="string">&#x27;adaptive&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109281947330.png"></p><hr><h2 id="Otsu-阈值法"><a href="#Otsu-阈值法" class="headerlink" title="Otsu 阈值法"></a>Otsu 阈值法</h2><p>二值化操作类型:</p><p><code>THRESH_OTSU</code>: 使用 Otsu 算法选取最优阈值，可与上述任何一种 type 组合</p><p>例如: <code>type=THRESH_OTSU+THRESH_BINARY</code> , 即先用 Otsu 算法自动计算出阈值，然后利用该阈值采用<code>THRESH_BINARY</code>规则,默认为<code>THRESH_BINARY</code></p><hr><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img=cv.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 图像灰度处理</span></span><br><span class="line">gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># Otsu阈值</span></span><br><span class="line">ret,dst=cv.threshold(gray,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_OTSU+cv.THRESH_BINARY)</span><br><span class="line"><span class="built_in">print</span>(ret) <span class="comment">#控制台打印算法选取的最优阈值</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>,gray)</span><br><span class="line">cv.imshow(<span class="string">&#x27;Otsu&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr><p>处理结果:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109282017226.png"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
            <tag> -opencv </tag>
            
            <tag> -图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建指南</title>
      <link href="/2021/09/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2021/09/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境部署"><a href="#1-环境部署" class="headerlink" title="1.环境部署"></a>1.环境部署</h1><h2 id="1-1-Nodejs-安装"><a href="#1-1-Nodejs-安装" class="headerlink" title="1.1 Nodejs 安装"></a>1.1 Nodejs 安装</h2><ul><li><p>进入官网选择对应的系统下载<br><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p></li><li><p>下载完成之后，要配置一下环境变量</p></li><li><p>配置好环境变量之后，进入 cmd 命令行窗口输入</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v <span class="comment">#npm为包管理工具</span></span><br></pre></td></tr></table></figure><ul><li>显示安装版本号，即安装成功。</li></ul><span id="more"></span><h2 id="1-2-Git-安装"><a href="#1-2-Git-安装" class="headerlink" title="1.2 Git 安装"></a>1.2 Git 安装</h2><ul><li>进入官网安装对应系统版本 <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li><li>配置系统环境变量</li><li>打开 git bash 输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -version</span><br></pre></td></tr></table></figure><ul><li><p>显示版本号即安装成功</p></li><li><p>后续进行相关的 git 补充配置</p></li></ul><h2 id="1-3-Hexo-安装"><a href="#1-3-Hexo-安装" class="headerlink" title="1.3 Hexo 安装"></a>1.3 Hexo 安装</h2><p>这里我们需要通过阿里的 cnpm 管理器进行安装，速度会快一点</p><hr><ul><li>这里通过 git-bash 窗口(cmd 也可以，注意一下以管理员的身份)安装 cnpm</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>查看 cnpm 版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><ul><li>安装 hexo 框架</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>安装结束之后，查看一下 hexo 版本，显示则成功,如果提示 hexo 无法识别的指令，需要配置一下环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="1-4-Hexo-配置"><a href="#1-4-Hexo-配置" class="headerlink" title="1.4 Hexo 配置"></a>1.4 Hexo 配置</h2><ul><li>下面我们需要创建一个博客的根目录，手动或者命令行都可以</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog #注意目录的路径,blog是文件名</span><br></pre></td></tr></table></figure><ul><li>初始化目录,初始化结束后 hexo 会自动生成所需的文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>启动本地博客服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动成功之后，会提供本地的访问地址，默认是 <a href="http://localhost:4000/">http://localhost:4000</a></p><hr><h2 id="1-5-部署到-github-上"><a href="#1-5-部署到-github-上" class="headerlink" title="1.5 部署到 github 上"></a>1.5 部署到 github 上</h2><ul><li>准备工作</li></ul><hr><p>登录 github，新建一个仓库，仓库名必须是:用户名.github.io ，并且需要初始化一个 Readme 文件。</p><hr><p>建好仓库之后，在 Setting 设置中找到 GitHub Pages 选项，可以找到 GitHub Pages 为我们创建好的域名</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171516892.png"></p><hr><ul><li>使用 ssh-keygen 生成私钥和公钥，会生成一个 id_ras.pub 文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa <span class="comment">#git bash命令行输入，注意这里要配置好git环境</span></span><br></pre></td></tr></table></figure><hr><p>找到 github 上 SSH and GPG keys 选项，点击 New SSH key</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171501849.png"></p><hr><p>将刚刚生成的公钥 id_ras.pub 文件里面的内容复制到 key 里面(记事本打开)</p><hr><ul><li>进入 bash 输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>第一次会让你进行 yes 确认，确认之后看到的是自己的用户名就成功了</p><hr><ul><li>本地 PC 完成推送部署<br>打开生成的博客根目录 blog 下的 hexo 配置文件 _config.yml,进行以下配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repo: git@github.com:用户名/仓库名.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure><p>这里要<strong>注意缩进</strong>，GitHub 的 branch 设置现在默认是 main，设置仓库分支的时候要设置成 master</p><ul><li>安装部署插件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><hr><ul><li>部署完成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>然后打开 github 分配的域名进行查看(之前 github pages 选项里面)</p><h1 id="2-Hexo-基本操作"><a href="#2-Hexo-基本操作" class="headerlink" title="2.Hexo 基本操作"></a>2.Hexo 基本操作</h1><ul><li>初始化博客</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>新建文章</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;文章名字&quot;</span><br></pre></td></tr></table></figure><p>新建文章会自动生成一个 md 文件,可以进行相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称</span><br><span class="line">date:  #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories:  #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，单个标签 -tag1 注意冒号:后面有个空格</span><br><span class="line">description: 摘要</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>新建页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;页面名字&quot;</span><br></pre></td></tr></table></figure><p>会在 source 文件夹下生成一个文件夹，其中 index.md 为页面内容</p><ul><li>清除缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><ul><li>生成静态页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><ul><li>启动本地服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>指定其他端口号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 端口号</span><br></pre></td></tr></table></figure><ul><li>部署</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="3-Hexo-进阶"><a href="#3-Hexo-进阶" class="headerlink" title="3.Hexo 进阶"></a>3.Hexo 进阶</h1><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>在 Hexo <a href="https://hexo.io/themes">主题官网</a>找到需要的主题，通过 git 克隆到本地仓库</p><p>修改 hexo 根目录下的_config.yml 中的 <code>theme: landscape</code> 换成需要的主题名</p><p>如<code>theme: Cxo</code></p><hr><h2 id="PicGo-GitHub-配置-CDN-图床"><a href="#PicGo-GitHub-配置-CDN-图床" class="headerlink" title="PicGo+GitHub 配置 CDN 图床"></a>PicGo+GitHub 配置 CDN 图床</h2><ul><li>创建 GitHub 图床仓库，仓库设置为 public，需要有初始化文件</li><li>获取 GitHub token 值</li></ul><p>step1:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171558349.png"></p><p>step2:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171558394.png"></p><p>step3:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171558695.png"></p><p>step4:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171558200.png"></p><p>step5:</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171604099.png"></p><p>之后会跳转到有 token 的页面，将 token 的值复制记录下来(<strong>只出现一次</strong>)用于 PicGo 绑定 GitHub</p><hr><ul><li><p>绑定 GitHub 图床</p><p>首先下载 PicGo 软件 <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p></li></ul><hr><p>然后设置 GitHub 图床</p><p><img src="https://cdn.jsdelivr.net/gh/code-jie123/code-jie123cdn/202109171612012.png"></p><hr><ul><li>PicGo 注意事项</li></ul><p><strong>仓库名不要有空格</strong></p><p><strong>图片名字不要带特殊字符</strong></p><p><strong>建议开启时间戳重命名，在 PicGo 设置中</strong></p><p><strong>上传图片间歇太短，在 PicGo 设置中关闭 Server</strong></p><ul><li>更多内容参考</li></ul><p>PicGo 操作手册 <a href="https://picgo.github.io/PicGo-Doc/zh/guide">https://picgo.github.io/PicGo-Doc/zh/guide</a></p><h1 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h1><ul><li>更多相关操作访问<a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2021/09/16/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/09/16/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>Welcome to Git Introduce,this article will be updated continuously</strong></p><h1 id="Git-介绍"><a href="#Git-介绍" class="headerlink" title="Git 介绍"></a>Git 介绍</h1><p>Git 是一款流行的代码版本管理工具，Git 是分布式版本控制系统，区别于 SVN 和 CSV 这样的集中式版本控制系统。</p>   <span id="more"></span><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><h2 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;url&gt; <span class="comment">#从远程仓库克隆代码</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">#初始化本地git仓库</span></span><br></pre></td></tr></table></figure><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="comment">#查看本地所有的分支</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r <span class="comment">#查看远程所有的分支</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a <span class="comment">#查看所有分支(本地和远程)</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged <span class="comment">#查看所有分支已合并到当前分支的分支</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;new-branch&gt; <span class="comment">#新建分支</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt; <span class="comment">#删除本地分支</span></span><br></pre></td></tr></table></figure><h2 id="本地更改"><a href="#本地更改" class="headerlink" title="本地更改"></a>本地更改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment">#查看当前分支的状态</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="comment">#查看跟踪文件的变更</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="comment">#将所有变更的文件添加到暂存区</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a <span class="comment">#提交所有本地更改</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;xxx&quot;</span> <span class="comment">#将已添加至暂存区的文件执行提交，并进行描述xxx</span></span><br></pre></td></tr></table></figure><h2 id="服务端提交"><a href="#服务端提交" class="headerlink" title="服务端提交"></a>服务端提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">#本地与服务器端进行同步</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="comment">#将本地分支推送到服务器端</span></span><br></pre></td></tr></table></figure><h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">#查看提交历史</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n <span class="comment">#显示n行日志,n为整数</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;commit&gt; <span class="comment">#查看提交日志和相关变动文件</span></span><br></pre></td></tr></table></figure><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt; <span class="comment">#删除文件</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r &lt;directory&gt; <span class="comment">#删除指定目录下的文件</span></span><br></pre></td></tr></table></figure><h2 id="撤销命令"><a href="#撤销命令" class="headerlink" title="撤销命令"></a>撤销命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit&gt; <span class="comment">#将当前版本重置为某一个提交状态，代码不变</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt; <span class="comment">#撤销提交</span></span><br></pre></td></tr></table></figure><h2 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list <span class="comment">#列出当前Git配置</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
